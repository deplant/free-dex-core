.globl	constructor
.public	constructor
.type	constructor, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7_with_init_storage$
}
;; constructor protection
GETGLOB 6
THROWIF 51
PUSHINT 1
SETGLOB 6
;; end constructor protection
; Decode input parameters
; Decode valueX
;; decode struct TokenDetails valueX
;; decode TokenDetails.name
LDREF
;; decode TokenDetails.symbol
LDREF
;; decode TokenDetails.decimals
LDU 8
;; decode TokenDetails.code
;; decode TvmCell
LDREF
;; decode TokenDetails.totalSupply
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
;; decode TokenDetails.totalGranted
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
;; build struct TokenDetails ss:7
BLKSWAP 6, 1
TUPLE 6
SWAP
; Decode valueY
;; decode struct TokenDetails valueY
;; decode TokenDetails.name
DUP
SREFS
EQINT 1
PUSHCONT {
	LDREF
	ENDS
	CTOS
}
IF
LDREF
;; decode TokenDetails.symbol
LDREF
;; decode TokenDetails.decimals
LDU 8
;; decode TokenDetails.code
;; decode TvmCell
LDREF
;; decode TokenDetails.totalSupply
LDU 128
;; decode TokenDetails.totalGranted
LDU 128
;; build struct TokenDetails ss:8
BLKSWAP 6, 1
TUPLE 6
SWAP
ENDS
;; param: valueX
;; param: valueY
; constructor DEXPool
; expValue
;; fetch detailsX_
GETGLOB 16
; end expValue
;; push identifier tokenX_
GETGLOB 14
; colValue
SETINDEX 0
SETGLOB 16
; end colValue
; expValue
;; fetch detailsY_
GETGLOB 17
; end expValue
;; push identifier tokenY_
GETGLOB 15
; colValue
SETINDEX 0
SETGLOB 17
; end colValue
; expValue
;; fetch detailsX_
GETGLOB 16
; end expValue
;; get member code
;; push identifier valueX
PUSH S2
INDEX 3
; colValue
SETINDEX 2
SETGLOB 16
; end colValue
; expValue
;; fetch detailsY_
GETGLOB 17
; end expValue
;; get member code
;; push identifier valueY
PUSH S1
INDEX 3
; colValue
SETINDEX 2
SETGLOB 17
; end colValue
; expValue
;; fetch detailsX_
GETGLOB 16
; end expValue
;; get member name
;; push identifier valueX
PUSH S2
INDEX 0
; colValue
SETINDEX 3
SETGLOB 16
; end colValue
; expValue
;; fetch detailsY_
GETGLOB 17
; end expValue
;; get member name
;; push identifier valueY
PUSH S1
INDEX 0
; colValue
SETINDEX 3
SETGLOB 17
; end colValue
; expValue
;; fetch detailsX_
GETGLOB 16
; end expValue
;; get member symbol
;; push identifier valueX
PUSH S2
INDEX 1
; colValue
SETINDEX 4
SETGLOB 16
; end colValue
; expValue
;; fetch detailsY_
GETGLOB 17
; end expValue
;; get member symbol
;; push identifier valueY
PUSH S1
INDEX 1
; colValue
SETINDEX 4
SETGLOB 17
; end colValue
; expValue
;; fetch detailsX_
GETGLOB 16
; end expValue
;; get member decimals
;; push identifier valueX
PUSH S2
INDEX 2
; colValue
SETINDEX 5
SETGLOB 16
; end colValue
; expValue
;; fetch detailsY_
GETGLOB 17
; end expValue
;; get member decimals
;; push identifier valueY
PUSH S1
INDEX 2
; colValue
SETINDEX 5
SETGLOB 17
; end colValue
CALL $_deployWallets_internal$
DROP2
; end constructor DEXPool
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	getTokenInfo
.public	getTokenInfo
.type	getTokenInfo, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
; function getTokenInfo
;; return
;; push identifier name_
GETGLOB 11
;; push identifier symbol_
GETGLOB 12
PUSHINT 12
;; push identifier code_
GETGLOB 13
;; push identifier total_supply_
GETGLOB 18
;; push identifier total_supply_
GETGLOB 18
TUPLE 6
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST x9e2f4ecc
	PUSH S1
	UNTUPLE 6
	BLKSWAP 1, 6
	PUSH S6
	STREFR
	PUSH S5
	STREFR
	PUSH S4
	STUR 8
	PUSH S3
	STREFR
	PUSH S2
	STUR 128
	PUSH S1
	STUR 128
	XCHG s6
	BLKDROP 6
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
; end function getTokenInfo
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	callTokenInfo
.public	callTokenInfo
.type	callTokenInfo, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
ENDS
; function callTokenInfo
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
PUSHINT 64
SETINDEXQ 4
SETGLOB 4
;; push identifier name_
GETGLOB 11
;; push identifier symbol_
GETGLOB 12
PUSHINT 12
;; push identifier code_
GETGLOB 13
;; push identifier total_supply_
GETGLOB 18
;; push identifier total_supply_
GETGLOB 18
TUPLE 6
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xe356f9c1
	PUSH S1
	UNTUPLE 6
	BLKSWAP 1, 6
	PUSH S6
	STREFR
	PUSH S5
	STREFR
	PUSH S4
	STUR 8
	PUSH S3
	STREFR
	PUSH S2
	STUR 128
	PUSH S1
	STUR 128
	XCHG s6
	BLKDROP 6
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 104
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S1
	UNTUPLE 6
	BLKSWAP 1, 6
	PUSH S6
	STREFR
	PUSH S5
	STREFR
	PUSH S4
	STUR 8
	PUSH S3
	STREFR
	PUSH S2
	STUR 128
	PUSH S1
	STUR 128
	XCHG s6
	BLKDROP 6
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP
; end function callTokenInfo
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	getWalletAddress
.public	getWalletAddress
.type	getWalletAddress, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode workchainId
LDI 8
; Decode walletPubkey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode walletOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: workchainId
;; param: walletPubkey
;; param: walletOwner
; function getWalletAddress
;; return
MYADDR
;; push identifier walletPubkey
PUSH S2
;; push identifier walletOwner
PUSH S2
CALL $_expectedAddress_internal$
XCHG s3
BLKDROP 3
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xdb4f57e1
	PUSH S1
	STSLICER
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
; end function getWalletAddress
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	callWalletAddress
.public	callWalletAddress
.type	callWalletAddress, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
; Decode workchainId
LDI 8
; Decode walletPubkey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode walletOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: workchainId
;; param: walletPubkey
;; param: walletOwner
; function callWalletAddress
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
PUSHINT 64
SETINDEXQ 4
SETGLOB 4
MYADDR
;; push identifier walletPubkey
PUSH S2
;; push identifier walletOwner
PUSH S2
CALL $_expectedAddress_internal$
XCHG s3
BLKDROP 3
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xb7cbe8d6
	PUSH S1
	STSLICER
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 104
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S1
	STSLICER
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP
; end function callWalletAddress
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	deployEmptyWallet
.public	deployEmptyWallet
.type	deployEmptyWallet, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode workchainId
LDI 8
; Decode walletPubkey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode walletOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode grams
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: workchainId
;; param: walletPubkey
;; param: walletOwner
;; param: grams
; function deployEmptyWallet
;; ret param: walletAddress
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
;; ret param: walletCode
NEWC
ENDC
ACCEPT
NEWDICT
;; push identifier walletPubkey
PUSH S5
NEWC
STU 256
PUSHINT 0
ROT
PUSHINT 64
DICTUSETB
MYADDR
PUSHINT 1
ROT
PUSHINT 64
DICTUSET
;; push identifier walletPubkey
PUSH S5
NEWC
STU 256
PUSHINT 2
ROT
PUSHINT 64
DICTUSETB
;; push identifier walletOwner
PUSH S4
PUSHINT 3
ROT
PUSHINT 64
DICTUSET
;; push identifier name_
GETGLOB 11
PUSHINT 4
ROT
PUSHINT 64
DICTUSETREF
;; push identifier symbol_
GETGLOB 12
PUSHINT 5
ROT
PUSHINT 64
DICTUSETREF
PUSHINT 12
NEWC
STU 8
PUSHINT 6
ROT
PUSHINT 64
DICTUSETB
;; push identifier code_
GETGLOB 13
PUSHINT 8
ROT
PUSHINT 64
DICTUSETREF
NEWC
STDICT
ENDC
;; push identifier code_
GETGLOB 13
NEWC
STSLICECONST x2_
STOPTREF
STOPTREF
STZERO
ENDC
DUP
HASHCU
;; push identifier workchainId
PUSH S7
NEWC
STSLICECONST x9_
STI 8
STU 256
ENDC
CTOS
;; push identifier grams
PUSH S4
PUSH S1
NEWC
STSLICECONST x62_
STSLICE
SWAP
STGRAMS
PUSHINT 105
STZEROES
STSLICECONST xc_
STSLICECONST 1
PUSH S2
STREFR
STSLICECONST 0
STSLICECONST x68b55f3f
ENDC
PUSHINT 0
SENDRAWMSG
NIP
; expValue
; end expValue
; colValue
POP S2
; end colValue
; expValue
; end expValue
;; push identifier code_
GETGLOB 13
; colValue
NIP
; end colValue
;; returning named params
BLKSWAP 4, 2
BLKDROP 4
;; emitting 2 value(s)
PUSH S2
EQINT -1
PUSHCONT {
	PUSH S4
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xd0917e72
	PUSH S2
	STSLICER
	PUSH S1
	STREFR
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP2
; end function deployEmptyWallet
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	getPoolDetails
.public	getPoolDetails
.type	getPoolDetails, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
; function getPoolDetails
;; ret param: details
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
PUSHINT 0
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
PUSHINT 0
PUSHINT 0
PUSHINT 0
TUPLE 8
;; get member root
;; push identifier detailsX_
GETGLOB 16
INDEX 0
;; get member wallet
;; push identifier detailsX_
GETGLOB 16
INDEX 1
;; get member balance
;; push identifier detailsX_
GETGLOB 16
INDEX 6
;; get member root
;; push identifier detailsY_
GETGLOB 17
INDEX 0
;; get member wallet
;; push identifier detailsY_
GETGLOB 17
INDEX 1
;; get member balance
;; push identifier detailsY_
GETGLOB 17
INDEX 6
PUSHINT 300
;; push identifier total_supply_
GETGLOB 18
TUPLE 8
; expValue
; end expValue
; colValue
NIP
; end colValue
;; returning named params
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 1
	NEWC
	STSLICECONST xe112acbd
	PUSH S2
	UNTUPLE 8
	BLKSWAP 1, 8
	PUSH S8
	STSLICER
	PUSH S7
	STSLICER
	PUSH S6
	STUR 128
	NEWC
	PUSH S6
	STSLICER
	PUSH S5
	STSLICER
	PUSH S4
	STUR 128
	PUSH S3
	STUR 128
	PUSH S2
	STUR 128
	BLKDROP2 8, 2
	STBREFR
	STBREFR
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
; end function getPoolDetails
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	getSwapDetails
.public	getSwapDetails
.type	getSwapDetails, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode _tokenAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: _tokenAddress
;; param: _tokens
; function getSwapDetails
;; push identifier _tokenAddress
PUSH S1
CALL $_processToken_internal$
ROTREV
ROTREV
ROTREV
;; decl: inToken
;; decl: outToken
;; get member balance
;; push identifier inToken
PUSH S2
INDEX 6
EQINT 0
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; get member balance
	;; push identifier outToken
	PUSH S1
	INDEX 6
	EQINT 0
}
IFNOT
PUSHCONT {
	PUSHINT 0
	PUSHINT 0
}
PUSHCONT {
	;; push identifier _tokens
	PUSH S3
	;; get member balance
	;; push identifier inToken
	PUSH S3
	INDEX 6
	;; get member balance
	;; push identifier outToken
	PUSH S3
	INDEX 6
	;; param: inAmount
	;; param: inBalance
	;; param: outBalance
	; function _spotAmount
	;; return
	;; push identifier outBalance
	DUP
	;; push identifier inAmount
	PUSH S3
	;; push identifier inBalance
	PUSH S3
	MULDIV
	UFITS 128
	XCHG s3
	BLKDROP 3
	; end function _spotAmount
	;; push identifier _tokens
	PUSH S4
	;; get member balance
	;; push identifier inToken
	PUSH S4
	INDEX 6
	;; get member balance
	;; push identifier outToken
	PUSH S4
	INDEX 6
	PUSHINT 300
	CALL $_effectiveAmount_internal$
}
IFELSE
SWAP
SWAP
;; decl: spotPrice
;; decl: effectivePrice
;; return
;; push identifier spotPrice
PUSH S1
;; push identifier effectivePrice
PUSH S1
TUPLE 2
XCHG s7
BLKDROP 7
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xcb5a7de9
	PUSH S1
	UNTUPLE 2
	ROT
	PUSH S2
	STUR 128
	PUSH S1
	STUR 128
	NIP
	NIP
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
; end function getSwapDetails
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	getDepositDetails
.public	getDepositDetails
.type	getDepositDetails, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode _tokenAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: _tokenAddress
;; param: _tokens
; function getDepositDetails
;; push identifier _tokenAddress
PUSH S1
CALL $_processToken_internal$
ROTREV
ROTREV
ROTREV
;; decl: inToken
;; decl: outToken
;; get member balance
;; push identifier inToken
PUSH S2
INDEX 6
EQINT 0
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; get member balance
	;; push identifier outToken
	PUSH S1
	INDEX 6
	EQINT 0
}
IFNOT
PUSHCONT {
	PUSHINT 0
	PUSHINT 0
}
PUSHCONT {
	;; push identifier _tokens
	PUSH S3
	;; get member balance
	;; push identifier inToken
	PUSH S3
	INDEX 6
	;; get member balance
	;; push identifier outToken
	PUSH S3
	INDEX 6
	;; param: inAmount
	;; param: inBalance
	;; param: outBalance
	; function _spotAmount
	;; return
	;; push identifier outBalance
	DUP
	;; push identifier inAmount
	PUSH S3
	;; push identifier inBalance
	PUSH S3
	MULDIV
	UFITS 128
	XCHG s3
	BLKDROP 3
	; end function _spotAmount
	;; push identifier _tokens
	PUSH S4
	;; push identifier _tokens
	PUSH S5
	;; get member balance
	;; push identifier inToken
	PUSH S5
	INDEX 6
	;; get member balance
	;; push identifier outToken
	PUSH S5
	INDEX 6
	;; param: inAmount
	;; param: inBalance
	;; param: outBalance
	; function _spotAmount
	;; return
	;; push identifier outBalance
	DUP
	;; push identifier inAmount
	PUSH S3
	;; push identifier inBalance
	PUSH S3
	MULDIV
	UFITS 128
	XCHG s3
	BLKDROP 3
	; end function _spotAmount
	;; param: inAmountX
	;; param: inAmountY
	; function _tokensToLiq
	;; return
	;; push identifier inAmountX
	PUSH S1
	;; push identifier inAmountY
	PUSH S1
	PUSHINT 1000
	;; *
	PUSHINT 1000
	MUL
	UFITS 128
	MULDIVC
	UFITS 128
	NIP
	NIP
	; end function _tokensToLiq
}
IFELSE
SWAP
SWAP
;; decl: secondAmount
;; decl: liqAmount
;; return
;; push identifier secondAmount
PUSH S1
;; push identifier liqAmount
PUSH S1
TUPLE 2
XCHG s7
BLKDROP 7
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xd23dfc24
	PUSH S1
	UNTUPLE 2
	ROT
	PUSH S2
	STUR 128
	PUSH S1
	STUR 128
	NIP
	NIP
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
; end function getDepositDetails
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	getWithdrawDetails
.public	getWithdrawDetails
.type	getWithdrawDetails, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode _tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: _tokens
; function getWithdrawDetails
;; get member balance
;; push identifier detailsX_
GETGLOB 16
INDEX 6
EQINT 0
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; get member balance
	;; push identifier detailsY_
	GETGLOB 17
	INDEX 6
	EQINT 0
}
IFNOT
PUSHCONT {
	PUSHINT 0
	PUSHINT 0
}
PUSHCONT {
	;; push identifier _tokens
	DUP
	;; push identifier total_supply_
	GETGLOB 18
	;; get member balance
	;; push identifier detailsX_
	GETGLOB 16
	INDEX 6
	;; get member balance
	;; push identifier detailsY_
	GETGLOB 17
	INDEX 6
	CALL $_liqToTokens_internal$
}
IFELSE
SWAP
SWAP
;; decl: amountX
;; decl: amountY
;; return
;; push identifier amountX
PUSH S1
;; push identifier amountY
PUSH S1
TUPLE 2
XCHG s3
BLKDROP 3
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST x82b3e116
	PUSH S1
	UNTUPLE 2
	ROT
	PUSH S2
	STUR 128
	PUSH S1
	STUR 128
	NIP
	NIP
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
; end function getWithdrawDetails
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	swap
.public	swap
.type	swap, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode _tokenAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _senderKey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode _senderOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
; Decode _minReturn
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: _tokenAddress
;; param: _senderKey
;; param: _senderOwner
;; param: _tokens
;; param: _minReturn
; modifier forCustomers
ACCEPT
; function _hasWallets
;; return
;; get member wallet
;; push identifier detailsX_
GETGLOB 16
INDEX 1
;; push identifier ZERO_ADDRESS
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SDEQ
NOT
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member wallet
	;; push identifier detailsY_
	GETGLOB 17
	INDEX 1
	;; push identifier ZERO_ADDRESS
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
; end function _hasWallets
THROWIFNOT 515
; function swap
CALL $_expireTransactions_internal$
;; push identifier _senderKey
PUSH S3
;; push identifier _senderOwner
PUSH S3
CALL $_processCustomer_internal$
;; decl: owner
;; !
;; push identifier owner
DUP
;; param: owner
; function _hasTransaction
;; return
;; map.exists
;; push identifier owner
DUP
;; push identifier transactions_
GETGLOB 19
PUSHINT 256
DICTUGET
DUP
PUSHCONT {
	NIP
}
IF
NIP
; end function _hasTransaction
NOT
THROWIFNOT 519
;; push identifier _tokenAddress
PUSH S5
CALL $_processToken_internal$
ROTREV
ROTREV
ROTREV
;; decl: inToken
;; decl: outToken
;; decl: xy
;; push identifier _tokens
PUSH S5
;; get member balance
;; push identifier inToken
PUSH S3
INDEX 6
;; get member balance
;; push identifier outToken
PUSH S3
INDEX 6
PUSHINT 300
CALL $_effectiveAmount_internal$
;; decl: outAmount
;; push identifier outAmount
DUP
;; >=
;; push identifier _minReturn
PUSH S6
GEQ
THROWIFNOT 516
;; get member balance
;; push identifier outToken
PUSH S2
INDEX 6
;; >=
PUSHINT 1000
;; +
;; push identifier _minReturn
PUSH S7
ADD
UFITS 128
GEQ
THROWIFNOT 520
;; get member root
;; push identifier inToken
PUSH S3
INDEX 0
;; push identifier _senderKey
PUSH S9
;; push identifier _senderOwner
PUSH S9
CALL $_expectedAddress_internal$
;; decl: from
;; push identifier now
NOW
;; push identifier _senderKey
PUSH S10
;; push identifier _senderOwner
PUSH S10
;; get member SWAP
PUSHINT 0
;; push identifier xy
PUSH S6
PUSHINT 0
;; push identifier _tokens
PUSH S13
PUSHINT 0
PUSHINT 0
;; push identifier _minReturn
PUSH S15
TUPLE 10
;; decl: tr
;; map.add
; expValue
;; fetch transactions_
GETGLOB 19
; end expValue
;; push identifier tr
PUSH S1
UNTUPLE 10
NEWC
NEWC
PUSH S2
STUR 128
STBREFR
PUSH S10
STUR 64
PUSH S9
STUR 256
PUSH S8
STSLICER
PUSH S7
STUR 8
PUSH S6
STIR 1
PUSH S5
STUR 8
PUSH S4
STUR 128
PUSH S3
STUR 128
PUSH S2
STUR 128
XCHG s10
BLKDROP 10
ENDC
;; push identifier owner
PUSH S8
ROT
PUSHINT 256
DICTUADDREF
SWAP
; colValue
SETGLOB 19
; end colValue
DROP
;; Remote call ITIP3WalletNotify.internalTransferFromNotify
;; push identifier from
PUSH S1
TRUE
NEWC
STSLICECONST x6_
STI 1
PUSHINT 3
STZEROES
STSLICE
PUSHSLICE x42faf0800000000000000000000000000004_
STSLICER
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x548968c1
;; to
;; get member wallet
;; push identifier inToken
PUSH S7
INDEX 1
STSLICER
;; tokens
;; push identifier _tokens
PUSH S10
STUR 128
;; subscriber
MYADDR
STSLICER
STBREFR
ENDC
PUSHINT 0
SENDRAWMSG
BLKDROP 7
; end function swap
BLKDROP 5
; end modifier forCustomers
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	deposit
.public	deposit
.type	deposit, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode _tokenAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _senderKey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode _senderOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
; Decode _maxSpend
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: _tokenAddress
;; param: _senderKey
;; param: _senderOwner
;; param: _tokens
;; param: _maxSpend
; modifier forCustomers
ACCEPT
; function _hasWallets
;; return
;; get member wallet
;; push identifier detailsX_
GETGLOB 16
INDEX 1
;; push identifier ZERO_ADDRESS
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SDEQ
NOT
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member wallet
	;; push identifier detailsY_
	GETGLOB 17
	INDEX 1
	;; push identifier ZERO_ADDRESS
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
; end function _hasWallets
THROWIFNOT 515
; function deposit
CALL $_expireTransactions_internal$
;; push identifier _senderKey
PUSH S3
;; push identifier _senderOwner
PUSH S3
CALL $_processCustomer_internal$
;; decl: owner
;; !
;; push identifier owner
DUP
;; param: owner
; function _hasTransaction
;; return
;; map.exists
;; push identifier owner
DUP
;; push identifier transactions_
GETGLOB 19
PUSHINT 256
DICTUGET
DUP
PUSHCONT {
	NIP
}
IF
NIP
; end function _hasTransaction
NOT
THROWIFNOT 519
;; push identifier _tokenAddress
PUSH S5
CALL $_processToken_internal$
ROTREV
ROTREV
ROTREV
;; decl: inToken
;; decl: outToken
;; decl: xy
;; get member balance
;; push identifier inToken
PUSH S2
INDEX 6
EQINT 0
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; get member balance
	;; push identifier outToken
	PUSH S1
	INDEX 6
	EQINT 0
}
IFNOT
PUSHCONT {
	;; push identifier _maxSpend
	PUSH S4
}
PUSHCONT {
	;; push identifier _tokens
	PUSH S5
	;; get member balance
	;; push identifier inToken
	PUSH S3
	INDEX 6
	;; get member balance
	;; push identifier outToken
	PUSH S3
	INDEX 6
	;; param: inAmount
	;; param: inBalance
	;; param: outBalance
	; function _spotAmount
	;; return
	;; push identifier outBalance
	DUP
	;; push identifier inAmount
	PUSH S3
	;; push identifier inBalance
	PUSH S3
	MULDIV
	UFITS 128
	XCHG s3
	BLKDROP 3
	; end function _spotAmount
}
IFELSE
;; decl: outAmount
;; push identifier outAmount
DUP
;; <=
;; push identifier _maxSpend
PUSH S6
LEQ
THROWIFNOT 517
;; push identifier outAmount
DUP
;; >=
PUSHINT 1000
GEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier _tokens
	PUSH S6
	;; >=
	PUSHINT 1000
	GEQ
}
IF
THROWIFNOT 520
;; get member root
;; push identifier inToken
PUSH S3
INDEX 0
;; push identifier _senderKey
PUSH S9
;; push identifier _senderOwner
PUSH S9
CALL $_expectedAddress_internal$
;; decl: fromIn
;; push identifier now
NOW
;; push identifier _senderKey
PUSH S10
;; push identifier _senderOwner
PUSH S10
;; get member DEPOSIT
PUSHINT 1
;; push identifier xy
PUSH S6
PUSHINT 0
;; push identifier _tokens
PUSH S13
;; push identifier outAmount
PUSH S8
PUSHINT 0
;; push identifier _maxSpend
PUSH S15
TUPLE 10
;; decl: tr
;; map.add
; expValue
;; fetch transactions_
GETGLOB 19
; end expValue
;; push identifier tr
PUSH S1
UNTUPLE 10
NEWC
NEWC
PUSH S2
STUR 128
STBREFR
PUSH S10
STUR 64
PUSH S9
STUR 256
PUSH S8
STSLICER
PUSH S7
STUR 8
PUSH S6
STIR 1
PUSH S5
STUR 8
PUSH S4
STUR 128
PUSH S3
STUR 128
PUSH S2
STUR 128
XCHG s10
BLKDROP 10
ENDC
;; push identifier owner
PUSH S8
ROT
PUSHINT 256
DICTUADDREF
SWAP
; colValue
SETGLOB 19
; end colValue
DROP
;; Remote call ITIP3WalletNotify.internalTransferFromNotify
;; push identifier fromIn
PUSH S1
TRUE
NEWC
STSLICECONST x6_
STI 1
PUSHINT 3
STZEROES
STSLICE
PUSHSLICE x42faf0800000000000000000000000000004_
STSLICER
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x548968c1
;; to
;; get member wallet
;; push identifier inToken
PUSH S7
INDEX 1
STSLICER
;; tokens
;; push identifier _tokens
PUSH S10
STUR 128
;; subscriber
MYADDR
STSLICER
STBREFR
ENDC
PUSHINT 0
SENDRAWMSG
BLKDROP 7
; end function deposit
BLKDROP 5
; end modifier forCustomers
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	withdraw
.public	withdraw
.type	withdraw, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode _senderKey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode _senderOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: _senderKey
;; param: _senderOwner
;; param: _tokens
; modifier forCustomers
ACCEPT
; function _hasWallets
;; return
;; get member wallet
;; push identifier detailsX_
GETGLOB 16
INDEX 1
;; push identifier ZERO_ADDRESS
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SDEQ
NOT
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member wallet
	;; push identifier detailsY_
	GETGLOB 17
	INDEX 1
	;; push identifier ZERO_ADDRESS
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
; end function _hasWallets
THROWIFNOT 515
; function withdraw
CALL $_expireTransactions_internal$
;; push identifier _senderKey
PUSH S2
;; push identifier _senderOwner
PUSH S2
CALL $_processCustomer_internal$
;; decl: owner
;; !
;; push identifier owner
DUP
;; param: owner
; function _hasTransaction
;; return
;; map.exists
;; push identifier owner
DUP
;; push identifier transactions_
GETGLOB 19
PUSHINT 256
DICTUGET
DUP
PUSHCONT {
	NIP
}
IF
NIP
; end function _hasTransaction
NOT
THROWIFNOT 519
;; get member balance
;; push identifier detailsX_
GETGLOB 16
INDEX 6
GTINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member balance
	;; push identifier detailsY_
	GETGLOB 17
	INDEX 6
	GTINT 0
}
IF
THROWIFNOT 520
;; push identifier _tokens
PUSH S1
;; >=
;; push identifier total_supply_
GETGLOB 18
;; get member balance
;; push identifier detailsX_
GETGLOB 16
INDEX 6
;; get member balance
;; push identifier detailsY_
GETGLOB 17
INDEX 6
CALL $_minWithdrawLiq_internal$
GEQ
THROWIFNOT 520
;; push identifier now
NOW
;; push identifier _senderKey
PUSH S4
;; push identifier _senderOwner
PUSH S4
;; get member WITHDRAW
PUSHINT 2
TRUE
PUSHINT 0
PUSHINT 0
PUSHINT 0
;; push identifier _tokens
PUSH S9
PUSHINT 0
TUPLE 10
;; decl: tr
;; map.add
; expValue
;; fetch transactions_
GETGLOB 19
; end expValue
;; push identifier tr
PUSH S1
UNTUPLE 10
NEWC
NEWC
PUSH S2
STUR 128
STBREFR
PUSH S10
STUR 64
PUSH S9
STUR 256
PUSH S8
STSLICER
PUSH S7
STUR 8
PUSH S6
STIR 1
PUSH S5
STUR 8
PUSH S4
STUR 128
PUSH S3
STUR 128
PUSH S2
STUR 128
XCHG s10
BLKDROP 10
ENDC
;; push identifier owner
PUSH S3
ROT
PUSHINT 256
DICTUADDREF
SWAP
; colValue
SETGLOB 19
; end colValue
DROP
MYADDR
;; push identifier _senderKey
PUSH S5
;; push identifier _senderOwner
PUSH S5
CALL $_expectedAddress_internal$
;; decl: from
;; Remote call ITIP3WalletRootBurnable.internalBurnFromRoot
;; push identifier from
DUP
TRUE
NEWC
STSLICECONST x6_
STI 1
PUSHINT 3
STZEROES
STSLICE
PUSHSLICE x42faf0800000000000000000000000000004_
STSLICER
STSLICECONST 0
STSLICECONST 0
STSLICECONST x5f8838f5
;; tokens
;; push identifier _tokens
PUSH S4
STUR 128
;; subscriber
MYADDR
STSLICER
ENDC
PUSHINT 0
SENDRAWMSG
BLKDROP 3
; end function withdraw
BLKDROP 3
; end modifier forCustomers
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	_deployWallets_internal
.type	_deployWallets_internal, @function
; function _deployWallets
;; Remote call ITIP3RootFungible.deployEmptyWallet
PUSHINT 1500000000
;; +
PUSHINT 200000000
ADD
UFITS 64
;; +
PUSHINT 50000000
ADD
UFITS 64
;; push identifier tokenX_
GETGLOB 14
NEWC
STSLICECONST x62_
STSLICE
SWAP
STGRAMS
PUSHINT 105
STZEROES
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x53eef447
STSLICECONST x2c9fcfbc
;; workchainId
PUSHINT 0
STIR 8
;; walletPubkey
PUSHINT 0
STUR 256
;; walletOwner
MYADDR
STSLICER
;; grams
PUSHINT 1500000000
STUR 128
STBREFR
ENDC
PUSHINT 0
SENDRAWMSG
;; Remote call ITIP3RootFungible.deployEmptyWallet
PUSHINT 1500000000
;; +
PUSHINT 200000000
ADD
UFITS 64
;; +
PUSHINT 50000000
ADD
UFITS 64
;; push identifier tokenY_
GETGLOB 15
NEWC
STSLICECONST x62_
STSLICE
SWAP
STGRAMS
PUSHINT 105
STZEROES
STSLICECONST 0
STSLICECONST 1
NEWC
STSLICECONST x53eef447
STSLICECONST x2c9fcfbc
;; workchainId
PUSHINT 0
STIR 8
;; walletPubkey
PUSHINT 0
STUR 256
;; walletOwner
MYADDR
STSLICER
;; grams
PUSHINT 1500000000
STUR 128
STBREFR
ENDC
PUSHINT 0
SENDRAWMSG
; end function _deployWallets

.globl	onWalletDeploy
.public	onWalletDeploy
.type	onWalletDeploy, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode walletAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode code
;; decode TvmCell
LDREF
ENDS
;; param: walletAddress
;; param: code
; modifier forCallbacks
;; get member value
CALLREF {
	CALL $message_balance_macro$
}
;; >=
PUSHINT 10000000
GEQ
THROWIFNOT 509
; function onWalletDeploy
;; if
;; get member sender
GETGLOB 9
;; push identifier tokenX_
GETGLOB 14
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member wallet
	;; push identifier detailsX_
	GETGLOB 16
	INDEX 1
	;; push identifier ZERO_ADDRESS
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
}
IF
PUSHCONT {
	; expValue
	;; fetch detailsX_
	GETGLOB 16
	; end expValue
	;; push identifier walletAddress
	PUSH S2
	; colValue
	SETINDEX 1
	SETGLOB 16
	; end colValue
}
PUSHCONT {
	;; if
	;; get member sender
	GETGLOB 9
	;; push identifier tokenY_
	GETGLOB 15
	SDEQ
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member wallet
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 1
		;; push identifier ZERO_ADDRESS
		;; address.makeAddrStd()
		PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
		SDEQ
	}
	IF
	PUSHCONT {
		; expValue
		;; fetch detailsY_
		GETGLOB 17
		; end expValue
		;; push identifier walletAddress
		PUSH S2
		; colValue
		SETINDEX 1
		SETGLOB 17
		; end colValue
	}
	IF
	;; end if
}
IFELSE
;; end if
; end function onWalletDeploy
DROP2
; end modifier forCallbacks
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	onWalletDeploy_internal
.type	onWalletDeploy_internal, @function
;; param: walletAddress
;; param: code
; modifier forCallbacks
;; get member value
CALLREF {
	CALL $message_balance_macro$
}
;; >=
PUSHINT 10000000
GEQ
THROWIFNOT 509
; function onWalletDeploy
;; if
;; get member sender
GETGLOB 9
;; push identifier tokenX_
GETGLOB 14
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member wallet
	;; push identifier detailsX_
	GETGLOB 16
	INDEX 1
	;; push identifier ZERO_ADDRESS
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
}
IF
PUSHCONT {
	; expValue
	;; fetch detailsX_
	GETGLOB 16
	; end expValue
	;; push identifier walletAddress
	PUSH S2
	; colValue
	SETINDEX 1
	SETGLOB 16
	; end colValue
}
PUSHCONT {
	;; if
	;; get member sender
	GETGLOB 9
	;; push identifier tokenY_
	GETGLOB 15
	SDEQ
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member wallet
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 1
		;; push identifier ZERO_ADDRESS
		;; address.makeAddrStd()
		PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
		SDEQ
	}
	IF
	PUSHCONT {
		; expValue
		;; fetch detailsY_
		GETGLOB 17
		; end expValue
		;; push identifier walletAddress
		PUSH S2
		; colValue
		SETINDEX 1
		SETGLOB 17
		; end colValue
	}
	IF
	;; end if
}
IFELSE
;; end if
; end function onWalletDeploy
DROP2
; end modifier forCallbacks

.globl	onWalletBurn
.public	onWalletBurn
.type	onWalletBurn, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode _tokenAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _senderKey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode _senderOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: _tokenAddress
;; param: _senderKey
;; param: _senderOwner
;; param: _tokens
; modifier forCallbacks
;; get member value
CALLREF {
	CALL $message_balance_macro$
}
;; >=
PUSHINT 10000000
GEQ
THROWIFNOT 509
; function onWalletBurn
;; push identifier _tokenAddress
PUSH S3
MYADDR
SDEQ
THROWIFNOT 506
;; push identifier _tokenAddress
PUSH S3
;; push identifier _senderKey
PUSH S3
;; push identifier _senderOwner
PUSH S3
CALL $_expectedAddress_internal$
;; decl: senderAddr
;; get member sender
GETGLOB 9
;; push identifier senderAddr
PUSH S1
SDEQ
THROWIFNOT 501
;; push identifier _senderKey
PUSH S3
;; push identifier _senderOwner
PUSH S3
CALL $_processCustomer_internal$
;; decl: owner
;; push identifier owner
DUP
CALL $_processTransaction_internal$
;; decl: tr
;; if
;; get member operation
;; push identifier tr
DUP
INDEX 3
;; ==
;; get member WITHDRAW
PUSHINT 2
EQUAL
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member stage
	;; push identifier tr
	DUP
	INDEX 5
	EQINT 0
}
IF
PUSHCONT {
	;; if
	;; get member amountLiq
	;; push identifier tr
	DUP
	INDEX 8
	;; ==
	;; push identifier _tokens
	PUSH S4
	EQUAL
	PUSHCONT {
		;; push identifier _tokens
		PUSH S3
		;; get member balance
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 6
		;; push identifier total_supply_
		GETGLOB 18
		MULDIV
		UFITS 128
		; expValue
		PUSH S1
		; end expValue
		SWAP
		; colValue
		SETINDEX 6
		NIP
		; end colValue
		;; get member amountIn
		;; push identifier tr
		DUP
		INDEX 6
		;; get member balance
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 6
		;; get member balance
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 6
		;; param: inAmount
		;; param: inBalance
		;; param: outBalance
		; function _spotAmount
		;; return
		;; push identifier outBalance
		DUP
		;; push identifier inAmount
		PUSH S3
		;; push identifier inBalance
		PUSH S3
		MULDIV
		UFITS 128
		XCHG s3
		BLKDROP 3
		; end function _spotAmount
		; expValue
		PUSH S1
		; end expValue
		SWAP
		; colValue
		SETINDEX 7
		NIP
		; end colValue
		;; Remote call ITIP3WalletFungible.internalTransferFrom
		;; get member wallet
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 1
		TRUE
		NEWC
		STSLICECONST x6_
		STI 1
		PUSHINT 3
		STZEROES
		STSLICE
		PUSHSLICE x40bebc200000000000000000000000000004_
		STSLICER
		STSLICECONST 0
		STSLICECONST 0
		STSLICECONST x7cb81835
		;; to
		;; push identifier senderAddr
		PUSH S3
		STSLICER
		;; tokens
		;; get member amountIn
		;; push identifier tr
		PUSH S1
		INDEX 6
		STUR 128
		ENDC
		PUSHINT 0
		SENDRAWMSG
		;; Remote call ITIP3WalletFungible.internalTransferFrom
		;; get member wallet
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 1
		TRUE
		NEWC
		STSLICECONST x6_
		STI 1
		PUSHINT 3
		STZEROES
		STSLICE
		PUSHSLICE x40bebc200000000000000000000000000004_
		STSLICER
		STSLICECONST 0
		STSLICECONST 0
		STSLICECONST x7cb81835
		;; to
		;; push identifier senderAddr
		PUSH S3
		STSLICER
		;; tokens
		;; get member amountOut
		;; push identifier tr
		PUSH S1
		INDEX 7
		STUR 128
		ENDC
		PUSHINT 0
		SENDRAWMSG
		;; push identifier owner
		PUSH S1
		;; push identifier tr
		PUSH S1
		;; param: user
		;; param: tr
		; function _savepoint
		;; map.getReplace
		; expValue
		;; fetch transactions_
		GETGLOB 19
		; end expValue
		;; push identifier tr
		PUSH S1
		UNTUPLE 10
		NEWC
		NEWC
		PUSH S2
		STUR 128
		STBREFR
		PUSH S10
		STUR 64
		PUSH S9
		STUR 256
		PUSH S8
		STSLICER
		PUSH S7
		STUR 8
		PUSH S6
		STIR 1
		PUSH S5
		STUR 8
		PUSH S4
		STUR 128
		PUSH S3
		STUR 128
		PUSH S2
		STUR 128
		XCHG s10
		BLKDROP 10
		ENDC
		;; push identifier user
		PUSH S3
		ROT
		PUSHINT 256
		DICTUREPLACEGETREF
		NULLSWAPIFNOT
		PUSHCONT {
			CTOS
			LDREF
			LDU 64
			LDU 256
			LDMSGADDR
			LDU 8
			LDI 1
			LDU 8
			LDU 128
			LDU 128
			PLDU 128
			BLKSWAP 1, 9
			CTOS
			PLDU 128
			TUPLE 10
		}
		IF
		SWAP
		; colValue
		SETGLOB 19
		; end colValue
		DROP
		DROP2
		; end function _savepoint
		;; push identifier owner
		PUSH S1
		CALL $_commit_internal$
	}
	PUSHCONT {
		;; push identifier owner
		PUSH S1
		CALL $_rollback_internal$
	}
	IFELSE
	;; end if
}
IF
;; end if
BLKDROP 3
; end function onWalletBurn
BLKDROP 4
; end modifier forCallbacks
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	onWalletBurn_internal
.type	onWalletBurn_internal, @function
;; param: _tokenAddress
;; param: _senderKey
;; param: _senderOwner
;; param: _tokens
; modifier forCallbacks
;; get member value
CALLREF {
	CALL $message_balance_macro$
}
;; >=
PUSHINT 10000000
GEQ
THROWIFNOT 509
; function onWalletBurn
;; push identifier _tokenAddress
PUSH S3
MYADDR
SDEQ
THROWIFNOT 506
;; push identifier _tokenAddress
PUSH S3
;; push identifier _senderKey
PUSH S3
;; push identifier _senderOwner
PUSH S3
CALL $_expectedAddress_internal$
;; decl: senderAddr
;; get member sender
GETGLOB 9
;; push identifier senderAddr
PUSH S1
SDEQ
THROWIFNOT 501
;; push identifier _senderKey
PUSH S3
;; push identifier _senderOwner
PUSH S3
CALL $_processCustomer_internal$
;; decl: owner
;; push identifier owner
DUP
CALL $_processTransaction_internal$
;; decl: tr
;; if
;; get member operation
;; push identifier tr
DUP
INDEX 3
;; ==
;; get member WITHDRAW
PUSHINT 2
EQUAL
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member stage
	;; push identifier tr
	DUP
	INDEX 5
	EQINT 0
}
IF
PUSHCONT {
	;; if
	;; get member amountLiq
	;; push identifier tr
	DUP
	INDEX 8
	;; ==
	;; push identifier _tokens
	PUSH S4
	EQUAL
	PUSHCONT {
		;; push identifier _tokens
		PUSH S3
		;; get member balance
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 6
		;; push identifier total_supply_
		GETGLOB 18
		MULDIV
		UFITS 128
		; expValue
		PUSH S1
		; end expValue
		SWAP
		; colValue
		SETINDEX 6
		NIP
		; end colValue
		;; get member amountIn
		;; push identifier tr
		DUP
		INDEX 6
		;; get member balance
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 6
		;; get member balance
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 6
		;; param: inAmount
		;; param: inBalance
		;; param: outBalance
		; function _spotAmount
		;; return
		;; push identifier outBalance
		DUP
		;; push identifier inAmount
		PUSH S3
		;; push identifier inBalance
		PUSH S3
		MULDIV
		UFITS 128
		XCHG s3
		BLKDROP 3
		; end function _spotAmount
		; expValue
		PUSH S1
		; end expValue
		SWAP
		; colValue
		SETINDEX 7
		NIP
		; end colValue
		;; Remote call ITIP3WalletFungible.internalTransferFrom
		;; get member wallet
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 1
		TRUE
		NEWC
		STSLICECONST x6_
		STI 1
		PUSHINT 3
		STZEROES
		STSLICE
		PUSHSLICE x40bebc200000000000000000000000000004_
		STSLICER
		STSLICECONST 0
		STSLICECONST 0
		STSLICECONST x7cb81835
		;; to
		;; push identifier senderAddr
		PUSH S3
		STSLICER
		;; tokens
		;; get member amountIn
		;; push identifier tr
		PUSH S1
		INDEX 6
		STUR 128
		ENDC
		PUSHINT 0
		SENDRAWMSG
		;; Remote call ITIP3WalletFungible.internalTransferFrom
		;; get member wallet
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 1
		TRUE
		NEWC
		STSLICECONST x6_
		STI 1
		PUSHINT 3
		STZEROES
		STSLICE
		PUSHSLICE x40bebc200000000000000000000000000004_
		STSLICER
		STSLICECONST 0
		STSLICECONST 0
		STSLICECONST x7cb81835
		;; to
		;; push identifier senderAddr
		PUSH S3
		STSLICER
		;; tokens
		;; get member amountOut
		;; push identifier tr
		PUSH S1
		INDEX 7
		STUR 128
		ENDC
		PUSHINT 0
		SENDRAWMSG
		;; push identifier owner
		PUSH S1
		;; push identifier tr
		PUSH S1
		;; param: user
		;; param: tr
		; function _savepoint
		;; map.getReplace
		; expValue
		;; fetch transactions_
		GETGLOB 19
		; end expValue
		;; push identifier tr
		PUSH S1
		UNTUPLE 10
		NEWC
		NEWC
		PUSH S2
		STUR 128
		STBREFR
		PUSH S10
		STUR 64
		PUSH S9
		STUR 256
		PUSH S8
		STSLICER
		PUSH S7
		STUR 8
		PUSH S6
		STIR 1
		PUSH S5
		STUR 8
		PUSH S4
		STUR 128
		PUSH S3
		STUR 128
		PUSH S2
		STUR 128
		XCHG s10
		BLKDROP 10
		ENDC
		;; push identifier user
		PUSH S3
		ROT
		PUSHINT 256
		DICTUREPLACEGETREF
		NULLSWAPIFNOT
		PUSHCONT {
			CTOS
			LDREF
			LDU 64
			LDU 256
			LDMSGADDR
			LDU 8
			LDI 1
			LDU 8
			LDU 128
			LDU 128
			PLDU 128
			BLKSWAP 1, 9
			CTOS
			PLDU 128
			TUPLE 10
		}
		IF
		SWAP
		; colValue
		SETGLOB 19
		; end colValue
		DROP
		DROP2
		; end function _savepoint
		;; push identifier owner
		PUSH S1
		CALL $_commit_internal$
	}
	PUSHCONT {
		;; push identifier owner
		PUSH S1
		CALL $_rollback_internal$
	}
	IFELSE
	;; end if
}
IF
;; end if
BLKDROP 3
; end function onWalletBurn
BLKDROP 4
; end modifier forCallbacks

.globl	onWalletReceive
.public	onWalletReceive
.type	onWalletReceive, @function
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode _tokenAddress
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _receiverKey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode _receiverOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _senderKey
LDUQ 256
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 256
}
IFNOT
; Decode _senderOwner
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode _tokens
LDUQ 128
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: _tokenAddress
;; param: _receiverKey
;; param: _receiverOwner
;; param: _senderKey
;; param: _senderOwner
;; param: _tokens
; modifier forCallbacks
;; get member value
CALLREF {
	CALL $message_balance_macro$
}
;; >=
PUSHINT 10000000
GEQ
THROWIFNOT 509
; function onWalletReceive
;; push identifier _tokenAddress
PUSH S5
CALL $_processToken_internal$
ROTREV
ROTREV
ROTREV
;; decl: inToken
;; decl: outToken
;; decl: xy
;; get member sender
GETGLOB 9
;; get member wallet
;; push identifier inToken
PUSH S3
INDEX 1
SDEQ
THROWIFNOT 501
;; push identifier _senderKey
PUSH S5
;; push identifier _senderOwner
PUSH S5
CALL $_processCustomer_internal$
;; decl: owner
;; push identifier owner
DUP
CALL $_processTransaction_internal$
;; decl: tr
;; if
;; get member operation
;; push identifier tr
DUP
INDEX 3
;; ==
;; get member SWAP
PUSHINT 0
EQUAL
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member stage
	;; push identifier tr
	DUP
	INDEX 5
	EQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member amountIn
		;; push identifier tr
		DUP
		INDEX 6
		;; ==
		;; push identifier _tokens
		PUSH S6
		EQUAL
	}
	IF
}
IF
PUSHCONT {
	;; push identifier _tokens
	PUSH S5
	;; get member balance
	;; push identifier inToken
	PUSH S5
	INDEX 6
	;; get member balance
	;; push identifier outToken
	PUSH S5
	INDEX 6
	PUSHINT 300
	CALL $_effectiveAmount_internal$
	; expValue
	PUSH S1
	; end expValue
	SWAP
	; colValue
	SETINDEX 7
	NIP
	; end colValue
	;; if
	;; get member amountOut
	;; push identifier tr
	DUP
	INDEX 7
	;; >=
	;; get member limit
	;; push identifier tr
	PUSH S1
	INDEX 9
	GEQ
	PUSHCONT {
		;; get member root
		;; push identifier outToken
		PUSH S3
		INDEX 0
		;; push identifier _senderKey
		PUSH S8
		;; push identifier _senderOwner
		PUSH S8
		CALL $_expectedAddress_internal$
		;; decl: to
		;; push identifier owner
		PUSH S2
		;; push identifier tr
		PUSH S2
		;; param: user
		;; param: tr
		; function _savepoint
		;; map.getReplace
		; expValue
		;; fetch transactions_
		GETGLOB 19
		; end expValue
		;; push identifier tr
		PUSH S1
		UNTUPLE 10
		NEWC
		NEWC
		PUSH S2
		STUR 128
		STBREFR
		PUSH S10
		STUR 64
		PUSH S9
		STUR 256
		PUSH S8
		STSLICER
		PUSH S7
		STUR 8
		PUSH S6
		STIR 1
		PUSH S5
		STUR 8
		PUSH S4
		STUR 128
		PUSH S3
		STUR 128
		PUSH S2
		STUR 128
		XCHG s10
		BLKDROP 10
		ENDC
		;; push identifier user
		PUSH S3
		ROT
		PUSHINT 256
		DICTUREPLACEGETREF
		NULLSWAPIFNOT
		PUSHCONT {
			CTOS
			LDREF
			LDU 64
			LDU 256
			LDMSGADDR
			LDU 8
			LDI 1
			LDU 8
			LDU 128
			LDU 128
			PLDU 128
			BLKSWAP 1, 9
			CTOS
			PLDU 128
			TUPLE 10
		}
		IF
		SWAP
		; colValue
		SETGLOB 19
		; end colValue
		DROP
		DROP2
		; end function _savepoint
		;; push identifier owner
		PUSH S2
		CALL $_commit_internal$
		;; Remote call ITIP3WalletFungible.internalTransferFrom
		;; get member wallet
		;; push identifier outToken
		PUSH S4
		INDEX 1
		TRUE
		NEWC
		STSLICECONST x6_
		STI 1
		PUSHINT 3
		STZEROES
		STSLICE
		PUSHSLICE x140000000000000000000000000004_
		STSLICER
		STSLICECONST 0
		STSLICECONST 0
		STSLICECONST x7cb81835
		;; to
		;; push identifier to
		PUSH S1
		STSLICER
		;; tokens
		;; get member amountOut
		;; push identifier tr
		PUSH S2
		INDEX 7
		STUR 128
		ENDC
		PUSHINT 0
		SENDRAWMSG
		DROP
	}
	PUSHCONT {
		;; push identifier owner
		PUSH S1
		CALL $_rollback_internal$
	}
	IFELSE
	;; end if
}
PUSHCONT {
	;; if
	;; get member operation
	;; push identifier tr
	DUP
	INDEX 3
	;; ==
	;; get member DEPOSIT
	PUSHINT 1
	EQUAL
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member stage
		;; push identifier tr
		DUP
		INDEX 5
		EQINT 0
		;; short-circuiting &&
		DUP
		PUSHCONT {
			DROP
			;; get member amountIn
			;; push identifier tr
			DUP
			INDEX 6
			;; ==
			;; push identifier _tokens
			PUSH S6
			EQUAL
		}
		IF
	}
	IF
	PUSHCONT {
		; expValue
		DUP
		; end expValue
		PUSHINT 1
		; colValue
		SETINDEX 5
		NIP
		; end colValue
		;; get member balance
		;; push identifier inToken
		PUSH S4
		INDEX 6
		EQINT 0
		;; short-circuiting ||
		DUP
		PUSHCONT {
			DROP
			;; get member balance
			;; push identifier outToken
			PUSH S3
			INDEX 6
			EQINT 0
		}
		IFNOT
		PUSHCONT {
			;; get member limit
			;; push identifier tr
			DUP
			INDEX 9
		}
		PUSHCONT {
			;; push identifier _tokens
			PUSH S5
			;; get member balance
			;; push identifier inToken
			PUSH S5
			INDEX 6
			;; get member balance
			;; push identifier outToken
			PUSH S5
			INDEX 6
			;; param: inAmount
			;; param: inBalance
			;; param: outBalance
			; function _spotAmount
			;; return
			;; push identifier outBalance
			DUP
			;; push identifier inAmount
			PUSH S3
			;; push identifier inBalance
			PUSH S3
			MULDIV
			UFITS 128
			XCHG s3
			BLKDROP 3
			; end function _spotAmount
		}
		IFELSE
		; expValue
		PUSH S1
		; end expValue
		SWAP
		; colValue
		SETINDEX 7
		NIP
		; end colValue
		;; push identifier owner
		PUSH S1
		;; push identifier tr
		PUSH S1
		;; param: user
		;; param: tr
		; function _savepoint
		;; map.getReplace
		; expValue
		;; fetch transactions_
		GETGLOB 19
		; end expValue
		;; push identifier tr
		PUSH S1
		UNTUPLE 10
		NEWC
		NEWC
		PUSH S2
		STUR 128
		STBREFR
		PUSH S10
		STUR 64
		PUSH S9
		STUR 256
		PUSH S8
		STSLICER
		PUSH S7
		STUR 8
		PUSH S6
		STIR 1
		PUSH S5
		STUR 8
		PUSH S4
		STUR 128
		PUSH S3
		STUR 128
		PUSH S2
		STUR 128
		XCHG s10
		BLKDROP 10
		ENDC
		;; push identifier user
		PUSH S3
		ROT
		PUSHINT 256
		DICTUREPLACEGETREF
		NULLSWAPIFNOT
		PUSHCONT {
			CTOS
			LDREF
			LDU 64
			LDU 256
			LDMSGADDR
			LDU 8
			LDI 1
			LDU 8
			LDU 128
			LDU 128
			PLDU 128
			BLKSWAP 1, 9
			CTOS
			PLDU 128
			TUPLE 10
		}
		IF
		SWAP
		; colValue
		SETGLOB 19
		; end colValue
		DROP
		DROP2
		; end function _savepoint
		;; get member root
		;; push identifier outToken
		PUSH S3
		INDEX 0
		;; push identifier _senderKey
		PUSH S8
		;; push identifier _senderOwner
		PUSH S8
		CALL $_expectedAddress_internal$
		;; decl: fromOut
		;; Remote call ITIP3WalletNotify.internalTransferFromNotify
		;; push identifier fromOut
		DUP
		TRUE
		NEWC
		STSLICECONST x6_
		STI 1
		PUSHINT 3
		STZEROES
		STSLICE
		PUSHSLICE x3989680000000000000000000000000004_
		STSLICER
		STSLICECONST 0
		STSLICECONST 1
		NEWC
		STSLICECONST x548968c1
		;; to
		;; get member wallet
		;; push identifier outToken
		PUSH S6
		INDEX 1
		STSLICER
		;; tokens
		;; get member amountOut
		;; push identifier tr
		PUSH S3
		INDEX 7
		STUR 128
		;; subscriber
		MYADDR
		STSLICER
		STBREFR
		ENDC
		PUSHINT 64
		SENDRAWMSG
		DROP
	}
	PUSHCONT {
		;; if
		;; get member operation
		;; push identifier tr
		DUP
		INDEX 3
		;; ==
		;; get member DEPOSIT
		PUSHINT 1
		EQUAL
		;; short-circuiting &&
		DUP
		PUSHCONT {
			DROP
			;; get member stage
			;; push identifier tr
			DUP
			INDEX 5
			EQINT 1
			;; short-circuiting &&
			DUP
			PUSHCONT {
				DROP
				;; get member amountOut
				;; push identifier tr
				DUP
				INDEX 7
				;; ==
				;; push identifier _tokens
				PUSH S6
				EQUAL
			}
			IF
		}
		IF
		PUSHCONT {
			MYADDR
			;; push identifier _senderKey
			PUSH S8
			;; push identifier _senderOwner
			PUSH S8
			CALL $_expectedAddress_internal$
			;; decl: to
			;; push identifier owner
			PUSH S2
			;; push identifier tr
			PUSH S2
			;; param: user
			;; param: tr
			; function _savepoint
			;; map.getReplace
			; expValue
			;; fetch transactions_
			GETGLOB 19
			; end expValue
			;; push identifier tr
			PUSH S1
			UNTUPLE 10
			NEWC
			NEWC
			PUSH S2
			STUR 128
			STBREFR
			PUSH S10
			STUR 64
			PUSH S9
			STUR 256
			PUSH S8
			STSLICER
			PUSH S7
			STUR 8
			PUSH S6
			STIR 1
			PUSH S5
			STUR 8
			PUSH S4
			STUR 128
			PUSH S3
			STUR 128
			PUSH S2
			STUR 128
			XCHG s10
			BLKDROP 10
			ENDC
			;; push identifier user
			PUSH S3
			ROT
			PUSHINT 256
			DICTUREPLACEGETREF
			NULLSWAPIFNOT
			PUSHCONT {
				CTOS
				LDREF
				LDU 64
				LDU 256
				LDMSGADDR
				LDU 8
				LDI 1
				LDU 8
				LDU 128
				LDU 128
				PLDU 128
				BLKSWAP 1, 9
				CTOS
				PLDU 128
				TUPLE 10
			}
			IF
			SWAP
			; colValue
			SETGLOB 19
			; end colValue
			DROP
			DROP2
			; end function _savepoint
			;; push identifier owner
			PUSH S2
			CALL $_commit_internal$
			;; Remote call ITIP3WalletFungible.accept
			;; push identifier to
			DUP
			TRUE
			NEWC
			STSLICECONST x6_
			STI 1
			PUSHINT 3
			STZEROES
			STSLICE
			PUSHSLICE x3989680000000000000000000000000004_
			STSLICER
			STSLICECONST 0
			STSLICECONST 0
			STSLICECONST x0b3fcf57
			;; tokens
			;; get member amountIn
			;; push identifier tr
			PUSH S2
			INDEX 6
			;; get member amountOut
			;; push identifier tr
			PUSH S3
			INDEX 7
			;; param: inAmountX
			;; param: inAmountY
			; function _tokensToLiq
			;; return
			;; push identifier inAmountX
			PUSH S1
			;; push identifier inAmountY
			PUSH S1
			PUSHINT 1000
			;; *
			PUSHINT 1000
			MUL
			UFITS 128
			MULDIVC
			UFITS 128
			NIP
			NIP
			; end function _tokensToLiq
			STUR 128
			ENDC
			PUSHINT 64
			SENDRAWMSG
			DROP
		}
		IF
		;; end if
	}
	IFELSE
	;; end if
}
IFELSE
;; end if
BLKDROP 5
; end function onWalletReceive
BLKDROP 6
; end modifier forCallbacks
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	onWalletReceive_internal
.type	onWalletReceive_internal, @function
;; param: _tokenAddress
;; param: _receiverKey
;; param: _receiverOwner
;; param: _senderKey
;; param: _senderOwner
;; param: _tokens
; modifier forCallbacks
;; get member value
CALLREF {
	CALL $message_balance_macro$
}
;; >=
PUSHINT 10000000
GEQ
THROWIFNOT 509
; function onWalletReceive
;; push identifier _tokenAddress
PUSH S5
CALL $_processToken_internal$
ROTREV
ROTREV
ROTREV
;; decl: inToken
;; decl: outToken
;; decl: xy
;; get member sender
GETGLOB 9
;; get member wallet
;; push identifier inToken
PUSH S3
INDEX 1
SDEQ
THROWIFNOT 501
;; push identifier _senderKey
PUSH S5
;; push identifier _senderOwner
PUSH S5
CALL $_processCustomer_internal$
;; decl: owner
;; push identifier owner
DUP
CALL $_processTransaction_internal$
;; decl: tr
;; if
;; get member operation
;; push identifier tr
DUP
INDEX 3
;; ==
;; get member SWAP
PUSHINT 0
EQUAL
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member stage
	;; push identifier tr
	DUP
	INDEX 5
	EQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member amountIn
		;; push identifier tr
		DUP
		INDEX 6
		;; ==
		;; push identifier _tokens
		PUSH S6
		EQUAL
	}
	IF
}
IF
PUSHCONT {
	;; push identifier _tokens
	PUSH S5
	;; get member balance
	;; push identifier inToken
	PUSH S5
	INDEX 6
	;; get member balance
	;; push identifier outToken
	PUSH S5
	INDEX 6
	PUSHINT 300
	CALL $_effectiveAmount_internal$
	; expValue
	PUSH S1
	; end expValue
	SWAP
	; colValue
	SETINDEX 7
	NIP
	; end colValue
	;; if
	;; get member amountOut
	;; push identifier tr
	DUP
	INDEX 7
	;; >=
	;; get member limit
	;; push identifier tr
	PUSH S1
	INDEX 9
	GEQ
	PUSHCONT {
		;; get member root
		;; push identifier outToken
		PUSH S3
		INDEX 0
		;; push identifier _senderKey
		PUSH S8
		;; push identifier _senderOwner
		PUSH S8
		CALL $_expectedAddress_internal$
		;; decl: to
		;; push identifier owner
		PUSH S2
		;; push identifier tr
		PUSH S2
		;; param: user
		;; param: tr
		; function _savepoint
		;; map.getReplace
		; expValue
		;; fetch transactions_
		GETGLOB 19
		; end expValue
		;; push identifier tr
		PUSH S1
		UNTUPLE 10
		NEWC
		NEWC
		PUSH S2
		STUR 128
		STBREFR
		PUSH S10
		STUR 64
		PUSH S9
		STUR 256
		PUSH S8
		STSLICER
		PUSH S7
		STUR 8
		PUSH S6
		STIR 1
		PUSH S5
		STUR 8
		PUSH S4
		STUR 128
		PUSH S3
		STUR 128
		PUSH S2
		STUR 128
		XCHG s10
		BLKDROP 10
		ENDC
		;; push identifier user
		PUSH S3
		ROT
		PUSHINT 256
		DICTUREPLACEGETREF
		NULLSWAPIFNOT
		PUSHCONT {
			CTOS
			LDREF
			LDU 64
			LDU 256
			LDMSGADDR
			LDU 8
			LDI 1
			LDU 8
			LDU 128
			LDU 128
			PLDU 128
			BLKSWAP 1, 9
			CTOS
			PLDU 128
			TUPLE 10
		}
		IF
		SWAP
		; colValue
		SETGLOB 19
		; end colValue
		DROP
		DROP2
		; end function _savepoint
		;; push identifier owner
		PUSH S2
		CALL $_commit_internal$
		;; Remote call ITIP3WalletFungible.internalTransferFrom
		;; get member wallet
		;; push identifier outToken
		PUSH S4
		INDEX 1
		TRUE
		NEWC
		STSLICECONST x6_
		STI 1
		PUSHINT 3
		STZEROES
		STSLICE
		PUSHSLICE x140000000000000000000000000004_
		STSLICER
		STSLICECONST 0
		STSLICECONST 0
		STSLICECONST x7cb81835
		;; to
		;; push identifier to
		PUSH S1
		STSLICER
		;; tokens
		;; get member amountOut
		;; push identifier tr
		PUSH S2
		INDEX 7
		STUR 128
		ENDC
		PUSHINT 0
		SENDRAWMSG
		DROP
	}
	PUSHCONT {
		;; push identifier owner
		PUSH S1
		CALL $_rollback_internal$
	}
	IFELSE
	;; end if
}
PUSHCONT {
	;; if
	;; get member operation
	;; push identifier tr
	DUP
	INDEX 3
	;; ==
	;; get member DEPOSIT
	PUSHINT 1
	EQUAL
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member stage
		;; push identifier tr
		DUP
		INDEX 5
		EQINT 0
		;; short-circuiting &&
		DUP
		PUSHCONT {
			DROP
			;; get member amountIn
			;; push identifier tr
			DUP
			INDEX 6
			;; ==
			;; push identifier _tokens
			PUSH S6
			EQUAL
		}
		IF
	}
	IF
	PUSHCONT {
		; expValue
		DUP
		; end expValue
		PUSHINT 1
		; colValue
		SETINDEX 5
		NIP
		; end colValue
		;; get member balance
		;; push identifier inToken
		PUSH S4
		INDEX 6
		EQINT 0
		;; short-circuiting ||
		DUP
		PUSHCONT {
			DROP
			;; get member balance
			;; push identifier outToken
			PUSH S3
			INDEX 6
			EQINT 0
		}
		IFNOT
		PUSHCONT {
			;; get member limit
			;; push identifier tr
			DUP
			INDEX 9
		}
		PUSHCONT {
			;; push identifier _tokens
			PUSH S5
			;; get member balance
			;; push identifier inToken
			PUSH S5
			INDEX 6
			;; get member balance
			;; push identifier outToken
			PUSH S5
			INDEX 6
			;; param: inAmount
			;; param: inBalance
			;; param: outBalance
			; function _spotAmount
			;; return
			;; push identifier outBalance
			DUP
			;; push identifier inAmount
			PUSH S3
			;; push identifier inBalance
			PUSH S3
			MULDIV
			UFITS 128
			XCHG s3
			BLKDROP 3
			; end function _spotAmount
		}
		IFELSE
		; expValue
		PUSH S1
		; end expValue
		SWAP
		; colValue
		SETINDEX 7
		NIP
		; end colValue
		;; push identifier owner
		PUSH S1
		;; push identifier tr
		PUSH S1
		;; param: user
		;; param: tr
		; function _savepoint
		;; map.getReplace
		; expValue
		;; fetch transactions_
		GETGLOB 19
		; end expValue
		;; push identifier tr
		PUSH S1
		UNTUPLE 10
		NEWC
		NEWC
		PUSH S2
		STUR 128
		STBREFR
		PUSH S10
		STUR 64
		PUSH S9
		STUR 256
		PUSH S8
		STSLICER
		PUSH S7
		STUR 8
		PUSH S6
		STIR 1
		PUSH S5
		STUR 8
		PUSH S4
		STUR 128
		PUSH S3
		STUR 128
		PUSH S2
		STUR 128
		XCHG s10
		BLKDROP 10
		ENDC
		;; push identifier user
		PUSH S3
		ROT
		PUSHINT 256
		DICTUREPLACEGETREF
		NULLSWAPIFNOT
		PUSHCONT {
			CTOS
			LDREF
			LDU 64
			LDU 256
			LDMSGADDR
			LDU 8
			LDI 1
			LDU 8
			LDU 128
			LDU 128
			PLDU 128
			BLKSWAP 1, 9
			CTOS
			PLDU 128
			TUPLE 10
		}
		IF
		SWAP
		; colValue
		SETGLOB 19
		; end colValue
		DROP
		DROP2
		; end function _savepoint
		;; get member root
		;; push identifier outToken
		PUSH S3
		INDEX 0
		;; push identifier _senderKey
		PUSH S8
		;; push identifier _senderOwner
		PUSH S8
		CALL $_expectedAddress_internal$
		;; decl: fromOut
		;; Remote call ITIP3WalletNotify.internalTransferFromNotify
		;; push identifier fromOut
		DUP
		TRUE
		NEWC
		STSLICECONST x6_
		STI 1
		PUSHINT 3
		STZEROES
		STSLICE
		PUSHSLICE x3989680000000000000000000000000004_
		STSLICER
		STSLICECONST 0
		STSLICECONST 1
		NEWC
		STSLICECONST x548968c1
		;; to
		;; get member wallet
		;; push identifier outToken
		PUSH S6
		INDEX 1
		STSLICER
		;; tokens
		;; get member amountOut
		;; push identifier tr
		PUSH S3
		INDEX 7
		STUR 128
		;; subscriber
		MYADDR
		STSLICER
		STBREFR
		ENDC
		PUSHINT 64
		SENDRAWMSG
		DROP
	}
	PUSHCONT {
		;; if
		;; get member operation
		;; push identifier tr
		DUP
		INDEX 3
		;; ==
		;; get member DEPOSIT
		PUSHINT 1
		EQUAL
		;; short-circuiting &&
		DUP
		PUSHCONT {
			DROP
			;; get member stage
			;; push identifier tr
			DUP
			INDEX 5
			EQINT 1
			;; short-circuiting &&
			DUP
			PUSHCONT {
				DROP
				;; get member amountOut
				;; push identifier tr
				DUP
				INDEX 7
				;; ==
				;; push identifier _tokens
				PUSH S6
				EQUAL
			}
			IF
		}
		IF
		PUSHCONT {
			MYADDR
			;; push identifier _senderKey
			PUSH S8
			;; push identifier _senderOwner
			PUSH S8
			CALL $_expectedAddress_internal$
			;; decl: to
			;; push identifier owner
			PUSH S2
			;; push identifier tr
			PUSH S2
			;; param: user
			;; param: tr
			; function _savepoint
			;; map.getReplace
			; expValue
			;; fetch transactions_
			GETGLOB 19
			; end expValue
			;; push identifier tr
			PUSH S1
			UNTUPLE 10
			NEWC
			NEWC
			PUSH S2
			STUR 128
			STBREFR
			PUSH S10
			STUR 64
			PUSH S9
			STUR 256
			PUSH S8
			STSLICER
			PUSH S7
			STUR 8
			PUSH S6
			STIR 1
			PUSH S5
			STUR 8
			PUSH S4
			STUR 128
			PUSH S3
			STUR 128
			PUSH S2
			STUR 128
			XCHG s10
			BLKDROP 10
			ENDC
			;; push identifier user
			PUSH S3
			ROT
			PUSHINT 256
			DICTUREPLACEGETREF
			NULLSWAPIFNOT
			PUSHCONT {
				CTOS
				LDREF
				LDU 64
				LDU 256
				LDMSGADDR
				LDU 8
				LDI 1
				LDU 8
				LDU 128
				LDU 128
				PLDU 128
				BLKSWAP 1, 9
				CTOS
				PLDU 128
				TUPLE 10
			}
			IF
			SWAP
			; colValue
			SETGLOB 19
			; end colValue
			DROP
			DROP2
			; end function _savepoint
			;; push identifier owner
			PUSH S2
			CALL $_commit_internal$
			;; Remote call ITIP3WalletFungible.accept
			;; push identifier to
			DUP
			TRUE
			NEWC
			STSLICECONST x6_
			STI 1
			PUSHINT 3
			STZEROES
			STSLICE
			PUSHSLICE x3989680000000000000000000000000004_
			STSLICER
			STSLICECONST 0
			STSLICECONST 0
			STSLICECONST x0b3fcf57
			;; tokens
			;; get member amountIn
			;; push identifier tr
			PUSH S2
			INDEX 6
			;; get member amountOut
			;; push identifier tr
			PUSH S3
			INDEX 7
			;; param: inAmountX
			;; param: inAmountY
			; function _tokensToLiq
			;; return
			;; push identifier inAmountX
			PUSH S1
			;; push identifier inAmountY
			PUSH S1
			PUSHINT 1000
			;; *
			PUSHINT 1000
			MUL
			UFITS 128
			MULDIVC
			UFITS 128
			NIP
			NIP
			; end function _tokensToLiq
			STUR 128
			ENDC
			PUSHINT 64
			SENDRAWMSG
			DROP
		}
		IF
		;; end if
	}
	IFELSE
	;; end if
}
IFELSE
;; end if
BLKDROP 5
; end function onWalletReceive
BLKDROP 6
; end modifier forCallbacks

.globl	_expireTransactions_internal
.type	_expireTransactions_internal, @function
; function _expireTransactions
;; map.min
;; push identifier transactions_
GETGLOB 19
PUSHINT 256
DICTUMINREF
NULLSWAPIFNOT
PUSHCONT {
	SWAP
	CTOS
	LDREF
	LDU 64
	LDU 256
	LDMSGADDR
	LDU 8
	LDI 1
	LDU 8
	LDU 128
	LDU 128
	PLDU 128
	BLKSWAP 1, 9
	CTOS
	PLDU 128
	TUPLE 10
	TUPLE 2
}
IF
;; decl: minRecord
;; if
;; push identifier minRecord
DUP
ISNULL
PUSHCONT {
	;; push identifier minRecord
	DUP
	DUP
	ISNULL
	THROWIF 63
	UNTUPLE 2
	SWAP
	SWAP
	;; decl: minUser
	;; decl: minTrans
	;; if
	;; push identifier now
	NOW
	;; >=
	;; get member created
	;; push identifier minTrans
	PUSH S1
	INDEX 0
	;; +
	PUSHINT 60
	ADD
	UFITS 64
	GEQ
	PUSHCONT {
		;; push identifier minUser
		PUSH S1
		CALL $_rollback_internal$
	}
	IF
	;; end if
	; while
	FALSE ; decl return flag
	PUSHCONT {
		DUP
		LESSINT 2
		DUP
		PUSHCONT {
			DROP
			TRUE
		}
		IF
	}
	PUSHCONT {
		;; map.next
		;; push identifier minUser
		PUSH S2
		;; push identifier transactions_
		GETGLOB 19
		PUSHINT 256
		DICTUGETNEXT
		NULLSWAPIFNOT
		PUSHCONT {
			SWAP
			PLDREF
			CTOS
			LDREF
			LDU 64
			LDU 256
			LDMSGADDR
			LDU 8
			LDI 1
			LDU 8
			LDU 128
			LDU 128
			PLDU 128
			BLKSWAP 1, 9
			CTOS
			PLDU 128
			TUPLE 10
			TUPLE 2
		}
		IF
		;; decl: nextRecord
		;; if
		FALSE ; decl return flag
		;; push identifier nextRecord
		PUSH S1
		ISNULL
		NOT
		PUSHCONT {
			;; push identifier nextRecord
			PUSH S1
			DUP
			ISNULL
			THROWIF 63
			UNTUPLE 2
			SWAP
			SWAP
			;; decl: nextUser
			;; decl: nextTrans
			;; if
			;; push identifier now
			NOW
			;; >=
			;; get member created
			;; push identifier nextTrans
			PUSH S1
			INDEX 0
			;; +
			PUSHINT 60
			ADD
			UFITS 64
			GEQ
			PUSHCONT {
				;; push identifier nextUser
				PUSH S1
				CALL $_rollback_internal$
			}
			IF
			;; end if
			; expValue
			; end expValue
			;; push identifier nextUser
			PUSH S1
			; colValue
			POP S7
			; end colValue
			DROP2
		}
		PUSHCONT {
			;; break
			BLKDROP 3
			PUSHINT 2
			RET
		}
		IFELSE
		DUP
		IFRET
		DROP
		;; end if
		DROP
	}
	WHILE
	DROP
	; end while
	DROP2
}
IFNOT
;; end if
DROP
; end function _expireTransactions

.globl	_commit_internal
.type	_commit_internal, @function
;; param: user
; function _commit
;; map.fetch
;; push identifier user
DUP
;; push identifier transactions_
GETGLOB 19
PUSHINT 256
DICTUGETREF
NULLSWAPIFNOT
PUSHCONT {
	CTOS
	LDREF
	LDU 64
	LDU 256
	LDMSGADDR
	LDU 8
	LDI 1
	LDU 8
	LDU 128
	LDU 128
	PLDU 128
	BLKSWAP 1, 9
	CTOS
	PLDU 128
	TUPLE 10
}
IF
DUP
ISNULL
THROWIF 63
;; decl: tr
;; if
;; get member operation
;; push identifier tr
DUP
INDEX 3
;; ==
;; get member WITHDRAW
PUSHINT 2
EQUAL
PUSHCONT {
	;; push identifier total_supply_
	GETGLOB 18
	;; get member amountLiq
	;; push identifier tr
	PUSH S1
	INDEX 8
	CALL $sub_internal$
	; expValue
	; end expValue
	; colValue
	SETGLOB 18
	; end colValue
	;; if
	;; get member xy
	;; push identifier tr
	DUP
	INDEX 4
	PUSHCONT {
		;; get member balance
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 6
		;; get member amountIn
		;; push identifier tr
		PUSH S1
		INDEX 6
		CALL $sub_internal$
		; expValue
		;; fetch detailsX_
		GETGLOB 16
		; end expValue
		SWAP
		; colValue
		SETINDEX 6
		SETGLOB 16
		; end colValue
		;; get member balance
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 6
		;; get member amountOut
		;; push identifier tr
		PUSH S1
		INDEX 7
		CALL $sub_internal$
		; expValue
		;; fetch detailsY_
		GETGLOB 17
		; end expValue
		SWAP
		; colValue
		SETINDEX 6
		SETGLOB 17
		; end colValue
	}
	PUSHCONT {
		;; get member balance
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 6
		;; get member amountIn
		;; push identifier tr
		PUSH S1
		INDEX 6
		CALL $sub_internal$
		; expValue
		;; fetch detailsY_
		GETGLOB 17
		; end expValue
		SWAP
		; colValue
		SETINDEX 6
		SETGLOB 17
		; end colValue
		;; get member balance
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 6
		;; get member amountOut
		;; push identifier tr
		PUSH S1
		INDEX 7
		CALL $sub_internal$
		; expValue
		;; fetch detailsX_
		GETGLOB 16
		; end expValue
		SWAP
		; colValue
		SETINDEX 6
		SETGLOB 16
		; end colValue
	}
	IFELSE
	;; end if
}
PUSHCONT {
	;; if
	;; get member operation
	;; push identifier tr
	DUP
	INDEX 3
	;; ==
	;; get member DEPOSIT
	PUSHINT 1
	EQUAL
	PUSHCONT {
		;; push identifier total_supply_
		GETGLOB 18
		;; get member amountLiq
		;; push identifier tr
		PUSH S1
		INDEX 8
		CALL $add_internal$
		; expValue
		; end expValue
		; colValue
		SETGLOB 18
		; end colValue
		;; if
		;; get member xy
		;; push identifier tr
		DUP
		INDEX 4
		PUSHCONT {
			;; get member balance
			;; push identifier detailsX_
			GETGLOB 16
			INDEX 6
			;; get member amountIn
			;; push identifier tr
			PUSH S1
			INDEX 6
			CALL $add_internal$
			; expValue
			;; fetch detailsX_
			GETGLOB 16
			; end expValue
			SWAP
			; colValue
			SETINDEX 6
			SETGLOB 16
			; end colValue
			;; get member balance
			;; push identifier detailsY_
			GETGLOB 17
			INDEX 6
			;; get member amountOut
			;; push identifier tr
			PUSH S1
			INDEX 7
			CALL $add_internal$
			; expValue
			;; fetch detailsY_
			GETGLOB 17
			; end expValue
			SWAP
			; colValue
			SETINDEX 6
			SETGLOB 17
			; end colValue
		}
		PUSHCONT {
			;; get member balance
			;; push identifier detailsY_
			GETGLOB 17
			INDEX 6
			;; get member amountIn
			;; push identifier tr
			PUSH S1
			INDEX 6
			CALL $add_internal$
			; expValue
			;; fetch detailsY_
			GETGLOB 17
			; end expValue
			SWAP
			; colValue
			SETINDEX 6
			SETGLOB 17
			; end colValue
			;; get member balance
			;; push identifier detailsX_
			GETGLOB 16
			INDEX 6
			;; get member amountOut
			;; push identifier tr
			PUSH S1
			INDEX 7
			CALL $add_internal$
			; expValue
			;; fetch detailsX_
			GETGLOB 16
			; end expValue
			SWAP
			; colValue
			SETINDEX 6
			SETGLOB 16
			; end colValue
		}
		IFELSE
		;; end if
	}
	PUSHCONT {
		;; if
		;; get member operation
		;; push identifier tr
		DUP
		INDEX 3
		;; ==
		;; get member SWAP
		PUSHINT 0
		EQUAL
		PUSHCONT {
			;; if
			;; get member xy
			;; push identifier tr
			DUP
			INDEX 4
			PUSHCONT {
				;; get member balance
				;; push identifier detailsX_
				GETGLOB 16
				INDEX 6
				;; get member amountIn
				;; push identifier tr
				PUSH S1
				INDEX 6
				CALL $add_internal$
				; expValue
				;; fetch detailsX_
				GETGLOB 16
				; end expValue
				SWAP
				; colValue
				SETINDEX 6
				SETGLOB 16
				; end colValue
				;; get member balance
				;; push identifier detailsY_
				GETGLOB 17
				INDEX 6
				;; get member amountOut
				;; push identifier tr
				PUSH S1
				INDEX 7
				CALL $sub_internal$
				; expValue
				;; fetch detailsY_
				GETGLOB 17
				; end expValue
				SWAP
				; colValue
				SETINDEX 6
				SETGLOB 17
				; end colValue
			}
			PUSHCONT {
				;; get member balance
				;; push identifier detailsY_
				GETGLOB 17
				INDEX 6
				;; get member amountIn
				;; push identifier tr
				PUSH S1
				INDEX 6
				CALL $add_internal$
				; expValue
				;; fetch detailsY_
				GETGLOB 17
				; end expValue
				SWAP
				; colValue
				SETINDEX 6
				SETGLOB 17
				; end colValue
				;; get member balance
				;; push identifier detailsX_
				GETGLOB 16
				INDEX 6
				;; get member amountOut
				;; push identifier tr
				PUSH S1
				INDEX 7
				CALL $sub_internal$
				; expValue
				;; fetch detailsX_
				GETGLOB 16
				; end expValue
				SWAP
				; colValue
				SETINDEX 6
				SETGLOB 16
				; end colValue
			}
			IFELSE
			;; end if
		}
		IF
		;; end if
	}
	IFELSE
	;; end if
}
IFELSE
;; end if
;; delete
; expValue
;; fetch transactions_
GETGLOB 19
;; push identifier user
PUSH S2
SWAP
; end expValue
PUSH S1
SWAP
PUSHINT 256
DICTUDEL
DROP
; colValue
NIP
SETGLOB 19
; end colValue
DROP2
; end function _commit

.globl	_rollback_internal
.type	_rollback_internal, @function
;; param: user
; function _rollback
;; map.fetch
;; push identifier user
DUP
;; push identifier transactions_
GETGLOB 19
PUSHINT 256
DICTUGETREF
NULLSWAPIFNOT
PUSHCONT {
	CTOS
	LDREF
	LDU 64
	LDU 256
	LDMSGADDR
	LDU 8
	LDI 1
	LDU 8
	LDU 128
	LDU 128
	PLDU 128
	BLKSWAP 1, 9
	CTOS
	PLDU 128
	TUPLE 10
}
IF
DUP
ISNULL
THROWIF 63
;; decl: tr
;; if
;; get member operation
;; push identifier tr
DUP
INDEX 3
;; ==
;; get member DEPOSIT
PUSHINT 1
EQUAL
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member stage
	;; push identifier tr
	DUP
	INDEX 5
	EQINT 1
}
IF
PUSHCONT {
	;; get member xy
	;; push identifier tr
	DUP
	INDEX 4
	PUSHCONT {
		;; get member wallet
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 1
		;; get member root
		;; push identifier detailsX_
		GETGLOB 16
		INDEX 0
		;; get member extOwner
		;; push identifier tr
		PUSH S2
		INDEX 1
		;; get member intOwner
		;; push identifier tr
		PUSH S3
		INDEX 2
		CALL $_expectedAddress_internal$
	}
	PUSHCONT {
		;; get member wallet
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 1
		;; get member root
		;; push identifier detailsY_
		GETGLOB 17
		INDEX 0
		;; get member extOwner
		;; push identifier tr
		PUSH S2
		INDEX 1
		;; get member intOwner
		;; push identifier tr
		PUSH S3
		INDEX 2
		CALL $_expectedAddress_internal$
	}
	IFELSE
	SWAP
	SWAP
	;; decl: from
	;; decl: to
	;; Remote call ITIP3WalletFungible.internalTransferFrom
	;; push identifier from
	PUSH S1
	TRUE
	NEWC
	STSLICECONST x6_
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	PUSHSLICE x402faf080000000000000000000000000004_
	STSLICER
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST x7cb81835
	;; to
	;; push identifier to
	PUSH S1
	STSLICER
	;; tokens
	;; get member amountIn
	;; push identifier tr
	PUSH S3
	INDEX 6
	STUR 128
	ENDC
	PUSHINT 0
	SENDRAWMSG
	DROP2
}
IF
;; end if
;; delete
; expValue
;; fetch transactions_
GETGLOB 19
;; push identifier user
PUSH S2
SWAP
; end expValue
PUSH S1
SWAP
PUSHINT 256
DICTUDEL
DROP
; colValue
NIP
SETGLOB 19
; end colValue
DROP2
; end function _rollback

.globl	_processCustomer_internal
.type	_processCustomer_internal, @function
;; param: _senderKey
;; param: _senderOwner
; function _processCustomer
PUSHINT 0
;; decl: owner
;; if
;; push identifier _senderKey
PUSH S2
NEQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier _senderOwner
	PUSH S1
	;; push identifier ZERO_ADDRESS
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
}
IF
PUSHCONT {
	; expValue
	; end expValue
	;; push identifier _senderKey
	PUSH S2
	; colValue
	NIP
	; end colValue
}
PUSHCONT {
	;; if
	;; push identifier _senderKey
	PUSH S2
	EQINT 0
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier _senderOwner
		PUSH S1
		;; push identifier ZERO_ADDRESS
		;; address.makeAddrStd()
		PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
		SDEQ
		NOT
	}
	IF
	PUSHCONT {
		; expValue
		; end expValue
		;; get member value
		;; push identifier _senderOwner
		PUSH S1
		PARSEMSGADDR
		INDEX 3
		PLDU 256
		; colValue
		NIP
		; end colValue
	}
	PUSHCONT {
		THROW 501
	}
	IFELSE
	;; end if
}
IFELSE
;; end if
;; return
NIP
NIP
; end function _processCustomer

.globl	_processToken_internal
.type	_processToken_internal, @function
;; param: _tokenAddress
; function _processToken
;; ret param: inToken
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
NEWC
ENDC
NEWC
ENDC
NEWC
ENDC
PUSHINT 0
PUSHINT 0
TUPLE 7
;; ret param: outToken
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
NEWC
ENDC
NEWC
ENDC
NEWC
ENDC
PUSHINT 0
PUSHINT 0
TUPLE 7
;; ret param: xy
PUSHINT 0
;; if
FALSE ; decl return flag
;; push identifier _tokenAddress
PUSH S4
;; push identifier tokenX_
GETGLOB 14
SDEQ
PUSHCONT {
	;; return
	;; push identifier detailsX_
	GETGLOB 16
	;; push identifier detailsY_
	GETGLOB 17
	TRUE
	BLKDROP2 5, 3
	PUSHINT 4
	RET
	BLKDROP 3
}
PUSHCONT {
	;; if
	FALSE ; decl return flag
	;; push identifier _tokenAddress
	PUSH S5
	;; push identifier tokenY_
	GETGLOB 15
	SDEQ
	PUSHCONT {
		;; return
		;; push identifier detailsY_
		GETGLOB 17
		;; push identifier detailsX_
		GETGLOB 16
		FALSE
		BLKDROP2 6, 3
		PUSHINT 4
		RET
		BLKDROP 3
	}
	PUSHCONT {
		THROW 506
	}
	IFELSE
	DUP
	IFRET
	DROP
	;; end if
}
IFELSE
EQINT 4
IFRET
;; end if
;; returning named params
BLKSWAP 1, 3
DROP
; end function _processToken

.globl	_processTransaction_internal
.type	_processTransaction_internal, @function
;; param: owner
; function _processTransaction
;; map.fetch
;; push identifier owner
DUP
;; push identifier transactions_
GETGLOB 19
PUSHINT 256
DICTUGETREF
NULLSWAPIFNOT
PUSHCONT {
	CTOS
	LDREF
	LDU 64
	LDU 256
	LDMSGADDR
	LDU 8
	LDI 1
	LDU 8
	LDU 128
	LDU 128
	PLDU 128
	BLKSWAP 1, 9
	CTOS
	PLDU 128
	TUPLE 10
}
IF
;; decl: opt
;; if
FALSE ; decl return flag
;; push identifier opt
PUSH S1
ISNULL
NOT
PUSHCONT {
	;; return
	;; push identifier opt
	PUSH S1
	DUP
	ISNULL
	THROWIF 63
	XCHG s3
	BLKDROP 3
	PUSHINT 4
	RET
	DROP
}
PUSHCONT {
	THROW 518
}
IFELSE
EQINT 4
IFRET
;; end if
DROP2
;; ret param: retParam@0
PUSHINT 0
PUSHINT 0
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
PUSHINT 0
PUSHINT 0
PUSHINT 0
PUSHINT 0
PUSHINT 0
PUSHINT 0
PUSHINT 0
TUPLE 10
; end function _processTransaction

.globl	_expectedAddress_internal
.type	_expectedAddress_internal, @function
;; param: _token
;; param: walletPubkey
;; param: walletOwner
; function _expectedAddress
NEWC
ENDC
;; decl: stateInit
;; if
;; push identifier _token
PUSH S3
MYADDR
SDEQ
PUSHCONT {
	NEWDICT
	;; push identifier walletPubkey
	PUSH S3
	NEWC
	STU 256
	PUSHINT 0
	ROT
	PUSHINT 64
	DICTUSETB
	MYADDR
	PUSHINT 1
	ROT
	PUSHINT 64
	DICTUSET
	;; push identifier walletPubkey
	PUSH S3
	NEWC
	STU 256
	PUSHINT 2
	ROT
	PUSHINT 64
	DICTUSETB
	;; push identifier walletOwner
	PUSH S2
	PUSHINT 3
	ROT
	PUSHINT 64
	DICTUSET
	;; push identifier name_
	GETGLOB 11
	PUSHINT 4
	ROT
	PUSHINT 64
	DICTUSETREF
	;; push identifier symbol_
	GETGLOB 12
	PUSHINT 5
	ROT
	PUSHINT 64
	DICTUSETREF
	PUSHINT 12
	NEWC
	STU 8
	PUSHINT 6
	ROT
	PUSHINT 64
	DICTUSETB
	;; push identifier code_
	GETGLOB 13
	PUSHINT 8
	ROT
	PUSHINT 64
	DICTUSETREF
	NEWC
	STDICT
	ENDC
	;; push identifier code_
	GETGLOB 13
	NEWC
	STSLICECONST x2_
	STOPTREF
	STOPTREF
	STZERO
	ENDC
	; expValue
	; end expValue
	; colValue
	NIP
	; end colValue
	;; return
	;; address.makeAddrStd()
	;; push identifier stateInit
	DUP
	HASHCU
	PUSHINT 0
	NEWC
	STSLICECONST x9_
	STI 8
	STU 256
	ENDC
	CTOS
	XCHG s4
	BLKDROP 4
	RET
}
PUSHCONT {
	;; if
	;; push identifier _token
	PUSH S3
	;; push identifier tokenX_
	GETGLOB 14
	SDEQ
	;; short-circuiting ||
	DUP
	PUSHCONT {
		DROP
		;; push identifier _token
		PUSH S3
		;; push identifier tokenY_
		GETGLOB 15
		SDEQ
	}
	IFNOT
	PUSHCONT {
		;; push identifier _token
		PUSH S3
		;; push identifier tokenX_
		GETGLOB 14
		SDEQ
		PUSHCONT {
			;; push identifier detailsX_
			GETGLOB 16
		}
		PUSHCONT {
			;; push identifier detailsY_
			GETGLOB 17
		}
		IFELSE
		;; decl: tk
		NEWDICT
		;; push identifier walletPubkey
		PUSH S4
		NEWC
		STU 256
		PUSHINT 0
		ROT
		PUSHINT 64
		DICTUSETB
		;; get member root
		;; push identifier tk
		PUSH S1
		INDEX 0
		PUSHINT 1
		ROT
		PUSHINT 64
		DICTUSET
		;; push identifier walletPubkey
		PUSH S4
		NEWC
		STU 256
		PUSHINT 2
		ROT
		PUSHINT 64
		DICTUSETB
		;; push identifier walletOwner
		PUSH S3
		PUSHINT 3
		ROT
		PUSHINT 64
		DICTUSET
		;; get member name
		;; push identifier tk
		PUSH S1
		INDEX 3
		PUSHINT 4
		ROT
		PUSHINT 64
		DICTUSETREF
		;; get member symbol
		;; push identifier tk
		PUSH S1
		INDEX 4
		PUSHINT 5
		ROT
		PUSHINT 64
		DICTUSETREF
		;; get member decimals
		;; push identifier tk
		PUSH S1
		INDEX 5
		NEWC
		STU 8
		PUSHINT 6
		ROT
		PUSHINT 64
		DICTUSETB
		;; get member code
		;; push identifier tk
		PUSH S1
		INDEX 2
		PUSHINT 8
		ROT
		PUSHINT 64
		DICTUSETREF
		NEWC
		STDICT
		ENDC
		;; get member code
		;; push identifier tk
		PUSH S1
		INDEX 2
		NEWC
		STSLICECONST x2_
		STOPTREF
		STOPTREF
		STZERO
		ENDC
		; expValue
		; end expValue
		; colValue
		POP S2
		; end colValue
		;; return
		;; address.makeAddrStd()
		;; push identifier stateInit
		PUSH S1
		HASHCU
		PUSHINT 0
		NEWC
		STSLICECONST x9_
		STI 8
		STU 256
		ENDC
		CTOS
		XCHG s5
		BLKDROP 5
		RET
	}
	PUSHCONT {
		;; return
		BLKDROP 4
		;; push identifier ZERO_ADDRESS
		;; address.makeAddrStd()
		PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
		RET
	}
	CONDSEL
	JMPX
	;; end if
}
CONDSEL
JMPX
;; end if
; end function _expectedAddress

.globl	add_internal
.type	add_internal, @function
;; param: x
;; param: y
; function add
;; ret param: z
PUSHINT 0
PUSHINT 300
;; push identifier x
PUSH S3
;; +
;; push identifier y
PUSH S3
ADD
UFITS 128
; expValue
; end expValue
PUSH s0
; colValue
POP S3
; end colValue
;; >=
;; push identifier x
PUSH S4
GEQ
THROWARGIFNOT 301
; expValue
; end expValue
;; push identifier x
PUSH S2
;; +
;; push identifier y
PUSH S2
ADD
UFITS 128
; colValue
NIP
; end colValue
;; returning named params
ROTREV
DROP2
; end function add

.globl	sub_internal
.type	sub_internal, @function
;; param: x
;; param: y
; function sub
;; ret param: z
PUSHINT 0
PUSHINT 301
;; push identifier x
PUSH S3
;; -
;; push identifier y
PUSH S3
SUB
UFITS 128
; expValue
; end expValue
PUSH s0
; colValue
POP S3
; end colValue
;; <=
;; push identifier x
PUSH S4
LEQ
THROWARGIFNOT 302
; expValue
; end expValue
;; push identifier x
PUSH S2
;; -
;; push identifier y
PUSH S2
SUB
UFITS 128
; colValue
NIP
; end colValue
;; returning named params
ROTREV
DROP2
; end function sub

.globl	mul_internal
.type	mul_internal, @function
;; param: x
;; param: y
; function mul
;; ret param: z
PUSHINT 0
PUSHINT 302
;; push identifier y
PUSH S2
EQINT 0
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; push identifier x
	PUSH S3
	;; *
	;; push identifier y
	PUSH S3
	MUL
	UFITS 128
	; expValue
	; end expValue
	PUSH s0
	; colValue
	POP S3
	; end colValue
	;; /
	;; push identifier y
	PUSH S3
	DIV
	;; ==
	;; push identifier x
	PUSH S4
	EQUAL
}
IFNOT
THROWARGIFNOT 303
; expValue
; end expValue
;; push identifier x
PUSH S2
;; *
;; push identifier y
PUSH S2
MUL
UFITS 128
; colValue
NIP
; end colValue
;; returning named params
ROTREV
DROP2
; end function mul

.globl	_effectiveAmount_internal
.type	_effectiveAmount_internal, @function
;; param: amountIn
;; param: balanceIn
;; param: balanceOut
;; param: fee
; function _effectiveAmount
;; return
;; push identifier balanceOut
PUSH S1
;; push identifier balanceIn
PUSH S3
;; push identifier balanceOut
PUSH S3
;; push identifier balanceIn
PUSH S5
;; push identifier amountIn
PUSH S7
CALL $add_internal$
;; push identifier amountIn
PUSH S7
;; push identifier fee
PUSH S5
PUSHINT 1000000
;; uint128
MULDIV
UFITS 128
CALL $sub_internal$
MULDIV
UFITS 128
CALL $sub_internal$
XCHG s4
BLKDROP 4
; end function _effectiveAmount

.globl	_liqToTokens_internal
.type	_liqToTokens_internal, @function
;; param: amountIn
;; param: supplyIn
;; param: balanceX
;; param: balanceY
; function _liqToTokens
;; ret param: outAmountX
PUSHINT 0
;; ret param: outAmountY
PUSHINT 0
;; push identifier amountIn
PUSH S5
;; push identifier balanceX
PUSH S4
;; push identifier supplyIn
PUSH S6
MULDIV
UFITS 128
;; *
PUSHINT 1000
MUL
UFITS 128
; expValue
; end expValue
; colValue
POP S2
; end colValue
;; push identifier outAmountX
PUSH S1
;; push identifier balanceX
PUSH S4
;; push identifier balanceY
PUSH S4
;; param: inAmount
;; param: inBalance
;; param: outBalance
; function _spotAmount
;; return
;; push identifier outBalance
DUP
;; push identifier inAmount
PUSH S3
;; push identifier inBalance
PUSH S3
MULDIV
UFITS 128
XCHG s3
BLKDROP 3
; end function _spotAmount
;; *
PUSHINT 1000
MUL
UFITS 128
; expValue
; end expValue
; colValue
NIP
; end colValue
;; returning named params
BLKSWAP 4, 2
BLKDROP 4
; end function _liqToTokens

.globl	_minDeposit_internal
.type	_minDeposit_internal, @function
;; param: balanceX
;; param: balanceY
; function _minDeposit
;; ret param: outAmountX
PUSHINT 0
;; ret param: outAmountY
PUSHINT 0
;; push identifier balanceX
PUSH S3
;; >
;; push identifier balanceY
PUSH S3
GREATER
PUSHCONT {
	PUSHINT 1000
	;; push identifier balanceX
	PUSH S4
	;; push identifier balanceY
	PUSH S4
	MULDIVC
	UFITS 128
	PUSHINT 1000
}
PUSHCONT {
	PUSHINT 1000
	PUSHINT 1000
	;; push identifier balanceY
	PUSH S4
	;; push identifier balanceX
	PUSH S6
	MULDIVC
	UFITS 128
}
IFELSE
SWAP
; expValue
; end expValue
; colValue
POP S3
; end colValue
; expValue
; end expValue
; colValue
NIP
; end colValue
;; returning named params
SWAP2
DROP2
; end function _minDeposit

.globl	_minWithdrawLiq_internal
.type	_minWithdrawLiq_internal, @function
;; param: supplyIn
;; param: balanceX
;; param: balanceY
; function _minWithdrawLiq
;; return
;; push identifier balanceX
PUSH S1
;; >
;; push identifier balanceY
PUSH S1
GREATER
PUSHCONT {
	PUSHINT 1000
	;; push identifier supplyIn
	PUSH S3
	;; push identifier balanceY
	PUSH S2
	MULDIVC
	UFITS 128
}
PUSHCONT {
	PUSHINT 1000
	;; push identifier supplyIn
	PUSH S3
	;; push identifier balanceX
	PUSH S3
	MULDIVC
	UFITS 128
}
IFELSE
XCHG s3
BLKDROP 3
; end function _minWithdrawLiq

.macro c7_to_c4
GETGLOB 2
NEWC
STU 256
GETGLOB 3
STUR 64
GETGLOB 6
STUR 1
NEWC
GETGLOB 13
GETGLOB 15
GETGLOB 16
GETGLOB 17
GETGLOB 18
REVERSE 6, 0
STREF
STSLICE
SWAP
UNTUPLE 7
NEWC
PUSH S7
STSLICER
PUSH S6
STSLICER
PUSH S5
STREFR
PUSH S4
STREFR
PUSH S3
STREFR
PUSH S2
STUR 8
PUSH S1
STUR 128
XCHG s7
BLKDROP 7
STBREFR
SWAP
UNTUPLE 7
NEWC
PUSH S7
STSLICER
PUSH S6
STSLICER
PUSH S5
STREFR
PUSH S4
STREFR
PUSH S3
STREFR
PUSH S2
STUR 8
PUSH S1
STUR 128
XCHG s7
BLKDROP 7
STBREFR
STU 128
GETGLOB 10
GETGLOB 11
GETGLOB 12
GETGLOB 14
GETGLOB 19
REVERSE 7, 0
STBREF
STSLICE
STREF
STREF
STSLICE
STDICT
ENDC
POP C4

.macro c4_to_c7
PUSHROOT
CTOS        ; c4
LDU 256      ; pubkey c4
LDU 64      ; pubkey timestamp c4
LDU 1       ; pubkey [timestamp] constructor_flag memory
LDREFRTOS
LDREF
LDMSGADDR
LDREFRTOS
LDMSGADDR
LDMSGADDR
LDREF
LDREF
LDREF
LDU 8
PLDU 128
TUPLE 7
SETGLOB 16
LDREFRTOS
LDMSGADDR
LDMSGADDR
LDREF
LDREF
LDREF
LDU 8
PLDU 128
TUPLE 7
SETGLOB 17
PLDU 128
SETGLOB 18
SETGLOB 15
SETGLOB 13
LDMSGADDR
LDREF
LDREF
LDMSGADDR
PLDDICT
SETGLOB 19
SETGLOB 14
SETGLOB 12
SETGLOB 11
SETGLOB 10
TRUE
SETGLOB 1   ; pubkey [timestamp] constructor_flag
SETGLOB 6   ; pubkey [timestamp]
SETGLOB 3   ; D
SETGLOB 2

.macro c4_to_c7_with_init_storage
PUSHROOT
CTOS        ; c4
DUP        ; c4 c4
SBITS      ; c4 bits
GTINT 1    ; c4 bits>1
PUSHCONT {
	LDU 256      ; pubkey c4
	LDU 64      ; pubkey timestamp c4
	LDU 1       ; pubkey [timestamp] constructor_flag memory
	LDREFRTOS
	LDREF
	LDMSGADDR
	LDREFRTOS
	LDMSGADDR
	LDMSGADDR
	LDREF
	LDREF
	LDREF
	LDU 8
	PLDU 128
	TUPLE 7
	SETGLOB 16
	LDREFRTOS
	LDMSGADDR
	LDMSGADDR
	LDREF
	LDREF
	LDREF
	LDU 8
	PLDU 128
	TUPLE 7
	SETGLOB 17
	PLDU 128
	SETGLOB 18
	SETGLOB 15
	SETGLOB 13
	LDMSGADDR
	LDREF
	LDREF
	LDMSGADDR
	PLDDICT
	SETGLOB 19
	SETGLOB 14
	SETGLOB 12
	SETGLOB 11
	SETGLOB 10
	TRUE
	SETGLOB 1   ; pubkey [timestamp] constructor_flag
	SETGLOB 6   ; pubkey [timestamp]
	SETGLOB 3   ; D
	SETGLOB 2
}
PUSHCONT {
	PLDDICT   ; D
	; init dex_
	PUSHINT 1
	PUSH S1
	PUSHINT 64
	DICTUGET
	PUSHCONT {
		PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	}
	IFNOT
	SETGLOB 10
	; init name_
	PUSHINT 2
	PUSH S1
	PUSHINT 64
	DICTUGETREF
	PUSHCONT {
		NEWC
		ENDC
	}
	IFNOT
	SETGLOB 11
	; init symbol_
	PUSHINT 3
	PUSH S1
	PUSHINT 64
	DICTUGETREF
	PUSHCONT {
		NEWC
		ENDC
	}
	IFNOT
	SETGLOB 12
	; init code_
	PUSHINT 4
	PUSH S1
	PUSHINT 64
	DICTUGETREF
	PUSHCONT {
		NEWC
		ENDC
	}
	IFNOT
	SETGLOB 13
	; init tokenX_
	PUSHINT 5
	PUSH S1
	PUSHINT 64
	DICTUGET
	PUSHCONT {
		PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	}
	IFNOT
	SETGLOB 14
	; init tokenY_
	PUSHINT 6
	PUSH S1
	PUSHINT 64
	DICTUGET
	PUSHCONT {
		PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	}
	IFNOT
	SETGLOB 15
	; init detailsX_
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	NEWC
	ENDC
	NEWC
	ENDC
	NEWC
	ENDC
	PUSHINT 0
	PUSHINT 0
	TUPLE 7
	SETGLOB 16
	; init detailsY_
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	NEWC
	ENDC
	NEWC
	ENDC
	NEWC
	ENDC
	PUSHINT 0
	PUSHINT 0
	TUPLE 7
	SETGLOB 17
	; init total_supply_
	PUSHINT 0
	SETGLOB 18
	; init transactions_
	NEWDICT
	SETGLOB 19
	; set contract pubkey
	PUSHINT 0
	SWAP
	PUSHINT 64
	DICTUGET
	THROWIFNOT 61
	PLDU 256
	SETGLOB 2
	PUSHINT 0 ; timestamp
	SETGLOB 3
	PUSHINT 0 ; constructor_flag
	SETGLOB 6
	TRUE
	SETGLOB 1
}
IFELSE

.internal-alias :main_internal,        0
.internal	:main_internal
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: main_internal
;; param: contract_balance
;; param: msg_balance
;; param: int_msg_info
;; param: msg_body_slice
PUSHINT 0  ; main_external trans id
PUSH S2
CTOS
LDU 4       ; bounced tail
LDMSGADDR   ; bounced src tail
DROP
SETGLOB 9
MODPOW2 1
; beg set default params for responsible func
GETGLOB 4
; bounce
TRUE
SETINDEXQ 1
; tons
PUSHINT 10000000
SETINDEXQ 2
; currency
NULL
SETINDEXQ 3
; flag
PUSHINT 0
SETINDEXQ 4
SETGLOB 4
; end set default params for responsible func
IFRET
PUSH S1    ; body
SEMPTY     ; isEmpty
IFRET
PUSH S1 ; body
LDU 32  ; funcId body'
PUSH S1 ; funcId body' funcId
IFNOTRET
PUSH S1 ; funcId body' funcId
LESSINT 3            ; funcId body' funcId<3
PUSH S2              ; funcId body' funcId<3 funcId
PUSHINT 4294967293   ; funcId body' funcId<3 funcId 4294967293
GREATER              ; funcId body' funcId<3 funcId>4294967293
OR                   ; funcId body' funcId<3||funcId>4294967293
PUSHCONT {
	DROP2
	THROW 60
}
IFJMP
SWAP    ; body funcId
CALL 1
GETGLOB 7
ISNULL
PUSHCONT {
	DROP
	THROW 60
}
IF

.internal-alias :main_external,        -1
.internal	:main_external
PUSHINT -1 ; main_external trans id
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SETGLOB 9
PUSH S1
CALL $c4_to_c7_with_init_storage$
LDU 1 ; haveSign msgSlice
SWAP
PUSHCONT {
	PUSHINT 512
	LDSLICEX ; signatureSlice msgSlice
	DUP      ; signatureSlice msgSlice msgSlice
	HASHSU   ; signatureSlice msgSlice hashMsgSlice
	SWAP  ; signatureSlice hashMsgSlice msgSlice
	LDU 1 ; signatureSlice hashMsgSlice havePubkey msgSlice
	SWAP  ; signatureSlice hashMsgSlice msgSlice havePubkey
	PUSHCONT {
		LDU 256       ; signatureSlice hashMsgSlice pubkey msgSlice
		XCHG s3
		SWAP
	}
	PUSHCONT {
		XCHG s2
		GETGLOB 2
	}
	IFELSE
	CHKSIGNU      ; msgSlice isSigned
	THROWIFNOT 40 ; msgSlice
}
PUSHCONT {
	LDU 1      ; havePubkey msgSlice
	SWAP       ; msgSlice havePubkey
	THROWIF 58 ; msgSlice
}
IFELSE
LDU 64                         ; timestamp msgSlice
SWAP                           ; msgSlice timestamp
CALL $replay_protection_macro$ ; msgSlice
LDU 32  ; expireAt msgSlice
SWAP    ; msgSlice expireAt
NOW     ; msgSlice expireAt now
GREATER ; msgSlice expireAt>now
THROWIFNOT 57
LDU  32 ; funcId body
PUSH S1 ; funcId body funcId
LESSINT 3            ; funcId body' funcId<3
PUSH S2              ; funcId body' funcId<3 funcId
PUSHINT 4294967293   ; funcId body' funcId<3 funcId 4294967293
GREATER              ; funcId body' funcId<3 funcId>4294967293
OR                   ; funcId body' funcId<3||funcId>4294967293
PUSHCONT {
	DROP2
	THROW 60
}
IFJMP
SWAP    ; body funcId
CALL 1
GETGLOB 7
ISNULL
PUSHCONT {
	DROP
	THROW 60
}
IF

